[
  {
    "path": "posts/2022-02-10-week04-02/",
    "title": "Introduction to Reactivity",
    "description": "Viewing shiny code execution as a graph.",
    "author": [
      {
        "name": "Kris Sankaran",
        "url": {}
      }
    ],
    "date": "2022-02-15",
    "categories": [],
    "contents": "\n\n\n\nReading, Recording, Rmarkdown\nThese notes will explore the idea of reactivity in more depth. Recall that reactivity refers to the fact that Shiny app code is not run from top to bottom, like an ordinary R script. Instead, it runs reactively, depending on inputs that the user has provided. This can make writing Shiny code a bit unintuitive at first, but there are a few higher-level concepts that can help when writing reactive code.\nThe most important of these concepts is that reactive code can be viewed as a graph. The ui and server define an explicit dependency structure for how components depend on one another. The input$’s within render* functions in the server specify how UI inputs affect server computations. The IDs within the *Output elements in the ui specify which of the rendered output$’s in the server should be used to populate the visible interface.\nFor example, our first “Hello” app has the following (simple) reactivity graph. Note that I’ve drawn input and output nodes differently, to emphasize the flow of computation. I’ve also copied the code from the original app for reference.\n\n\n\n\n\nlibrary(shiny)\n\n ui <- fluidPage(\n   titlePanel(\"Hello!\"),\n   textInput(\"name\", \"Enter your name\"),\n   textOutput(\"printed_name\")\n )\n\n server <- function(input, output) {\n   output$printed_name <- renderText({\n     paste0(\"Welcome to shiny, \", input$name, \"!\")\n   })\n }\n\n app <- shinyApp(ui, server)\n \n\n\n\n\n\nEven though the graph is simple, note that the outputs will be recomputed each time that the input is changed. For more general graphs, all downstream nodes will be re-executed whenever an upstream source is changed (typically by a user input, though it’s possible to trigger changes automatically).\nReactive expressions provide a special kind of node that live between inputs and outputs. They depend on inputs, and they feed into outputs, but they are never made directly visible to the user. This is why we’ve drawn them as a kind of special intermediate node. Below, I’ve drawn the graph for our random normal plotter, with the reactive samples() expression.\n\n\n\n\n\nlibrary(shiny)\n library(tidyverse)\n\n ### Functions within app components\n generate_data <- function(n, mean, sigma) {\n   data.frame(values = rnorm(n, mean, sigma))\n }\n\n histogram_fun <- function(df) {\n   ggplot(df) +\n     geom_histogram(aes(values), bins = 100) +\n     xlim(-10, 10)\n }\n\n ### Defines the app\n ui <- fluidPage(\n   titlePanel(\"Random Normals\"),\n   numericInput(\"mean\", \"Enter the mean\", 0),\n   sliderInput(\"n\", \"Enter the number of samples\", 500, min=1, max=2000),\n   sliderInput(\"sigma\", \"Enter the standard deviation\", 1, min=.1, max=5),\n   plotOutput(\"histogram\"),\n   dataTableOutput(\"dt\")\n )\n\n server <- function(input, output) {\n   samples <- reactive({\n     generate_data(input$n, input$mean, input$sigma)\n   })\n   output$histogram <- renderPlot(histogram_fun(samples()))\n   output$dt <- renderDataTable(samples())\n }\n\n app <- shinyApp(ui, server)\n \n\n\n\n\n\nA useful perspective is to think of reactive expressions as simplifying the overall reactivity graph. Specifically, by adding a reactive node, it’s possible to trim away many edges. For example, our initial implementation of the random normal plotter (which didn’t use the reactive expression) has a much more complicated graph, since many inputs feed directly into outputs.\n\n\n\nLet’s see these principles in action for a similar, but more complex app. The app below can be used for power analysis. It simulates two groups of samples, both from normal distributions, but with different (user specified) means. We’ve used a reactive expression to generate the samples, so that both the histogram and hypothesis test result outputs can refer to the same intermediate simulated data.\n\n\nlibrary(shiny)\n library(tidyverse)\n library(broom)\n\n ### Functions within app components\n generate_data <- function(n, mean1, mean2, sigma) {\n   data.frame(\n     values = c(rnorm(n, mean1, sigma), rnorm(n, mean2, sigma)),\n     group = rep(c(\"A\", \"B\"), each = n)\n   )\n }\n\n histogram_fun <- function(df) {\n   ggplot(df) +\n     geom_histogram(\n       aes(values, fill = group), \n       bins = 100, position = \"identity\",\n       alpha = 0.8\n     ) +\n     xlim(-10, 10)\n }\n\n test_fun <- function(df) {\n   t.test(values ~ group, data = df) %>%\n     tidy() %>%\n     select(p.value, conf.low, conf.high)\n }\n\n ### Defines the app\n ui <- fluidPage(\n   sidebarLayout(\n     sidebarPanel(\n       sliderInput(\"mean1\", \"Mean (Group 1)\", 0, min = -10.0, max = 10.0, step = 0.1),\n       sliderInput(\"mean2\", \"Mean (Group 2)\", 0, min = -10, max = 10, step = 0.1),\n       sliderInput(\"sigma\", \"Enter the standard deviation\", 1, min=.1, max=5),\n       sliderInput(\"n\", \"Enter the number of samples\", 500, min=1, max=2000),\n     ),\n     mainPanel(\n       plotOutput(\"histogram\"),\n       dataTableOutput(\"test_result\")\n     )\n   )\n )\n\n server <- function(input, output) {\n   samples <- reactive({\n     generate_data(input$n, input$mean1, input$mean2, input$sigma)\n   })\n   output$histogram <- renderPlot(histogram_fun(generate_data(input$n, input$mean1, ...)))\n   output$test_result <- renderPlot(test_fun(generate_data(input$n, input$mean1, ...)))\n }\n\n app <- shinyApp(ui, server)\n \n\n\n\n\n\nOther than that, the only difference is that I’ve saved output from the t.test using test_result. Notice the use of the broom package, which helps format the test output into a data.frame.\nSo far, all of our reactive code has lived within the render* or reactive() sets of functions. However, there is a another kind that is often useful, especially in more advanced applications: observers. An observer is a computation that is done every time certain inputs are changed, but which don’t affect downstream UI outputs through a render* function. For example, below, we’ve added a block (under observeEvent) that prints to the console every time either of the means are changed. I realize it is a bit of a mystery why these functions would ever be useful, but we will see them in more realistic contexts next week.\n\n\nlibrary(shiny)\n library(tidyverse)\n library(broom)\n\n ### Functions within app components\n generate_data <- function(n, mean1, mean2, sigma) {\n   data.frame(\n     values = c(rnorm(n, mean1, sigma), rnorm(n, mean2, sigma)),\n     group = rep(c(\"A\", \"B\"), each = n)\n   )\n }\n\n histogram_fun <- function(df) {\n   ggplot(df) +\n     geom_histogram(\n       aes(values, fill = group), \n       bins = 100, position = \"identity\",\n       alpha = 0.8\n     ) +\n     xlim(-10, 10)\n }\n\n test_fun <- function(df) {\n   t.test(values ~ group, data = df) %>%\n     tidy() %>%\n     select(p.value, conf.low, conf.high)\n }\n\n ### Defines the app\n ui <- fluidPage(\n   sidebarLayout(\n     sidebarPanel(\n       sliderInput(\"mean1\", \"Mean (Group 1)\", 0, min = -10.0, max = 10.0, step = 0.1),\n       sliderInput(\"mean2\", \"Mean (Group 2)\", 0, min = -10, max = 10, step = 0.1),\n       sliderInput(\"sigma\", \"Enter the standard deviation\", 1, min=.1, max=5),\n       sliderInput(\"n\", \"Enter the number of samples\", 500, min=1, max=2000),\n     ),\n     mainPanel(\n       plotOutput(\"histogram\"),\n       dataTableOutput(\"test_result\")\n     )\n   )\n )\n\n server <- function(input, output) {\n   samples <- reactive({\n     generate_data(input$n, input$mean1, input$mean2, input$sigma)\n   })\n   output$histogram <- renderPlot(histogram_fun(samples()))\n   output$test_result <- renderDataTable(test_fun(samples()))\n   observeEvent(input$mean1 | input$mean2, {\n     message(\"group 1 mean is now: \", input$mean1)\n     message(\"group 2 mean is now: \", input$mean2)\n   })\n }\n\n app <- shinyApp(ui, server)\n \n\n\n\n\n\n\n\n\n",
    "preview": "posts/2022-02-10-week04-02/figures/names.png",
    "last_modified": "2022-02-20T09:55:36-06:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-02-10-week04-03/",
    "title": "IMDB Shiny Application",
    "description": "Using Shiny to explore a movies dataset.",
    "author": [
      {
        "name": "Kris Sankaran",
        "url": {}
      }
    ],
    "date": "2022-02-15",
    "categories": [],
    "contents": "\n\n\n\nReading, Recording, Rmarkdown\nSo far, all of our Shiny applications have been based on toy simulated data. In this set of notes, we’ll use Shiny to explore a real dataset, illustrating the general development workflow in the process. Before diving into code, let’s consider the role of interactivity in data analysis.\nA major difference between doing visualization on paper and on computers is that visualization on computers can make use of interactivity. An interactive visualization is one that changes in response to user cues. This allows a display to update in a way that provides a visual comparison that was not available in a previous view. In this way, interactive visualization allows users to answer a sequence of questions.\nSelection, both of observations and of attributes, is fundamental to interactive visualization. This is because it precedes other interactive operations: you can select a subset of observations to filter down to or attributes to coordinate across multiple displays (we consider both types of interactivity in later lectures).\nThe code below selects movies to highlight based on Genre. We use a selectInput to create the dropdown menu. A reactive expression creates a new column (selected) in the movies dataset specifiying whether the current movie is selected. The reactive graph structure means that the ggplot2 figure is recreated each time the selection is changed, and the selected column is used to shade in the points. This process of changing the visual encoding of graphical marks depending on user selections is called “conditional encoding.”\n\n\nlibrary(shiny)\n library(tidyverse)\n library(lubridate)\n\n movies <- read_csv(\"https://raw.githubusercontent.com/krisrs1128/stat479_s22/main/_posts/2022-02-10-week04-03/apps/data/movies.csv\") %>%\n   mutate(\n     date = as_date(Release_Date, format = \"%b %d %Y\"),\n     year = year(date),\n     Major_Genre = fct_explicit_na(Major_Genre),\n     MPAA_Rating = fct_explicit_na(MPAA_Rating),\n   )\n\n genres <- pull(movies, Major_Genre) %>%\n   unique() %>%\n   na.omit()\n\n ### functions used in app\n scatterplot <- function(df) {\n   ggplot(df) +\n     geom_point(\n       aes(Rotten_Tomatoes_Rating, IMDB_Rating, size = selected, alpha = selected)\n     ) +\n     scale_size(limits = c(0, 1), range = c(.5, 2), guide = \"none\") +\n     scale_alpha(limits = c(0, 1), range = c(.1, 1), guide = \"none\")\n }\n\n ### definition of app\n ui <- fluidPage(\n   titlePanel(\"IMDB Analysis\"),\n   selectInput(\"genres\", \"Genre\", genres),\n   plotOutput(\"ratings_scatter\")\n )\n\n server <- function(input, output) {\n   movies_subset <- reactive({\n     movies %>%\n       mutate(selected = 1 * (Major_Genre %in% input$genres))\n   })\n\n   output$ratings_scatter <- renderPlot({\n     scatterplot(movies_subset())\n   })\n }\n\n app <- shinyApp(ui, server)\n \n\n\n\n\n\n\n\n\nWe can extend this further. Let’s allow the user to filter by year and MPAA rating. Notice that there are some years in the future! We also find that there are systematic differences in IMDB and Rotten Tomatoes ratings as a function of these variables.\n\n\nlibrary(shiny)\n library(tidyverse)\n library(lubridate)\n\n movies <- read_csv(\"https://raw.githubusercontent.com/krisrs1128/stat479_s22/main/_posts/2022-02-10-week04-03/apps/data/movies.csv\") %>%\n   mutate(\n     date = as_date(Release_Date, format = \"%b %d %Y\"),\n     year = year(date),\n     Major_Genre = fct_explicit_na(Major_Genre),\n     MPAA_Rating = fct_explicit_na(MPAA_Rating),\n   )\n\n genres <- pull(movies, Major_Genre) %>%\n   unique() %>%\n   na.omit()\n ratings <- pull(movies, MPAA_Rating) %>%\n   unique() %>%\n   na.omit()\n\n ### functions used in app\n scatterplot <- function(df) {\n   ggplot(df) +\n     geom_point(\n       aes(Rotten_Tomatoes_Rating, IMDB_Rating, size = selected, alpha = selected)\n     ) +\n     scale_size(limits = c(0, 1), range = c(.5, 2), guide = \"none\") +\n     scale_alpha(limits = c(0, 1), range = c(.1, 1), guide = \"none\")\n }\n\n ### definition of app\n ui <- fluidPage(\n   titlePanel(\"IMDB Analysis\"),\n   selectInput(\"genres\", \"Genre\", genres, multiple = TRUE),\n   checkboxGroupInput(\"mpaa\", \"MPAA Rating\", ratings, ratings),\n   sliderInput(\"year\", \"Year\", min = min(movies$year), max = max(movies$year), c(1928, 2020), sep = \"\"),\n   plotOutput(\"ratings_scatter\")\n )\n\n server <- function(input, output) {\n   movies_subset <- reactive({\n     movies %>%\n       mutate(selected = 1 * (\n         (Major_Genre %in% input$genres) &\n         (MPAA_Rating %in% input$mpaa) &\n         (year >= input$year[1]) &\n         (year <= input$year[2])\n       ))\n   })\n\n   output$ratings_scatter <- renderPlot({\n     scatterplot(movies_subset())\n   })\n }\n\n app <- shinyApp(ui, server)\n \n\n\n\n\n\n\n\n\nWe’ll include a final version of this plot which additionally shows the movie name when points are hovered. To accomplish this, we can no longer use ggplot2 on its own – it has to be linked with a plotting library that renders web-based visualizations (not just static image files). This is what the ggplotly() call does in the updated version of the app. The mouseover text is added through the tooltip argument.\n\n\nlibrary(shiny)\n library(tidyverse)\n library(lubridate)\n library(plotly)\n\n movies <- read_csv(\"https://raw.githubusercontent.com/krisrs1128/stat479_s22/main/_posts/2022-02-10-week04-03/apps/data/movies.csv\") %>%\n   mutate(\n     date = as_date(Release_Date, format = \"%b %d %Y\"),\n     year = year(date),\n     Major_Genre = fct_explicit_na(Major_Genre),\n     MPAA_Rating = fct_explicit_na(MPAA_Rating),\n   )\n\n genres <- pull(movies, Major_Genre) %>%\n   unique() %>%\n   na.omit()\n ratings <- pull(movies, MPAA_Rating) %>%\n   unique() %>%\n   na.omit()\n\n ### functions used in app\n scatterplot <- function(df) {\n   p <- ggplot(mapping = aes(Rotten_Tomatoes_Rating, IMDB_Rating)) +\n     geom_point(data = df %>% filter(selected),  aes(text = Title), size = 2, alpha = 1) +\n     geom_point(data = df %>% filter(!selected),  size = .5, alpha = .1)\n   ggplotly(p, tooltip = \"Title\") %>%\n     style(hoveron = \"fill\")\n }\n\n ### definition of app\n ui <- fluidPage(\n   titlePanel(\"IMDB Analysis\"),\n   selectInput(\"genres\", \"Genre\", genres),\n   checkboxGroupInput(\"mpaa\", \"MPAA Rating\", ratings, ratings),\n   sliderInput(\"year\", \"Year\", min = min(movies$year), max = max(movies$year), c(1928, 2020), sep = \"\"),\n   plotlyOutput(\"ratings_scatter\")\n )\n\n server <- function(input, output) {\n   movies_subset <- reactive({\n     movies %>%\n       mutate(selected = (\n         (Major_Genre %in% input$genres) &\n         (MPAA_Rating %in% input$mpaa) &\n         (year >= input$year[1]) &\n         (year <= input$year[2])\n       ))\n   })\n\n   output$ratings_scatter <- renderPlotly({\n     scatterplot(movies_subset())\n   })\n }\n\n app <- shinyApp(ui, server)\n \n\n\n\n\n\nThese visualizations are an instance of the more general idea of using filtering to reduce complexity in data. Filtering is an especially powerful technique in the interactive paradigm, where it is possible to easily reverse (or compare) filtering choices.\nConceptually, what we are doing falls under the name of “Dynamic Querying,” which refers more generally to updating a visualization based on user queries. There are several ways to think about these dynamic queries,\nInterpretation 1: Dynamic queries create the visual analog of a database interaction. Rather than using a programming-based interface to filter elements or select attributes, we can design interactive visual equivalents.\nInterpretation 2: Dynamic queries allow rapid evaluation of conditional probabilities. The visualization above was designed to answer: What is the joint distribution of movie ratings, conditional on being a drama?\n\n",
    "preview": "posts/2022-02-10-week04-03/app1.png",
    "last_modified": "2022-02-20T09:55:38-06:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-02-16-week05-01/",
    "title": "Graphical Queries: Click Events",
    "description": "An introduction to click events in Shiny.",
    "author": [
      {
        "name": "Kris Sankaran",
        "url": {}
      }
    ],
    "date": "2022-02-15",
    "categories": [],
    "contents": "\n\n\n\nReading, Recording, Rmarkdown\nSome of the most sophisticated interactive data visualizations are based on the idea that user queries can themselves be defined visually. For example, to select a date range, we could directly interact with a time series plot, rather than relying on a slider input. Or, instead of a long dropdown menu of items, a user could select items by clicking on bars in a bar plot. There are many variations of this idea, but they all leverage graphical (rather than textual) displays to define queries. The advantage of this approach is that it increases information density – the selection inputs themselves encode data.\nTo implement this in Shiny, we first need a way of registering user interactions on plots themselves. We will consider two types of plot interaction mechanisms: clicks and brushes. These can be specified by adding click or brush events to plotOutput objects.\nThis creates a UI with a single plot on which we will be able to track user clicks,\n\n\nui <- fluidPage(\n   plotOutput(\"plot\", click = \"plot_click\")\n )\n \n\n\nHere, plot_click is an ID that can be used as input$plot_click in the server. We could name it however we want, but we need to be consistent across the UI and server (just like ordinary, non-graphical inputs).\nBefore, we just needed to place the input$id items within render and reactive server components, and the associated outputs would automatically know to redraw each time the value of any input was changed. Clicks are treated slightly differently. We have to both (a) recognize when a click event has occurred and (b) extract relevant information about what the click was referring to.\nFor (a), we generally use observeEvent,\n\nobserveEvent(\n  input$plot_click,\n  ... things to do when the plot is clicked ...\n)\n\nThis piece of code will be run anytime the plot is clicked.\nFor (b), we can use the nearPoints helper function. Suppose the plot was made using the data.frame x. Then\n\n\nnearPoints(x, input$click)\n \n\n\nwill return the samples in x that are close to the clicked location. We will often use a variant of this code that doesn’t just return the closeby samples – it returns all samples, along with their distance from the clicked location,\n\n\nnearPoints(x, input$click, allRows = TRUE, addDist = TRUE)\n \n\n\nWe are almost ready to build a visualization whose outputs respond to graphical queries. Suppose we want a scatterplot where point sizes update according to their distance from the user’s click. Everytime the plot is clicked, we need to update the set of distances between samples and the clicked point. We then need to rerender the plot to reflect the new distances. This logic is captured by the block below,\n\n\nserver <- function(input, output) {\n   dist <- reactiveVal(rep(1, nrow(x)))\n   observeEvent(\n     input$plot_click,\n     dist(reset_dist(x, input$plot_click))\n   )\n\n   output$plot <- renderPlot({\n     scatter(x, dist())\n   })\n }\n \n\n\nThe code above uses one new concept, the reactiveVal on the first line of the function. It is a variable that doesn’t directly depend on any inputs, which can become a source node for downstream reactive and render nodes in the reactive graph. Anytime the variable’s value is changed, all downstream nodes will be recomputed. A very common pattern is use an observeEvent to update a reactiveVal every time a graphical query is performed. Any plots that depend on this value will then be updated. For example,\n\nval <- reactiveVal(initial_val) # initialize the reactive value\n\nobserveEvent(\n  ...some input event...\n  ...do some computation...\n  val(new_value) # update val to new_val\n)\n\n# runs each time the reactiveVal changes\nrenderPlot({\n  val() # get the current value of the reactive value\n})\n\nSo, revisiting the dist in the earlier code block, we see that it is initialized as a vector of 1’s whose length is equal to the number of rows of x. Everytime the plot is clicked, we update the value of dist according to the function reset_dist. Finally, the changed value of dist triggers a rerun of renderPlot. Let’s look at the full application in action. It makes a scatterplot using the cars dataset and resizes points every time the plot is clicked.\n\n\nlibrary(tidyverse)\n library(shiny)\n\n # wrapper to get the distances from points to clicks\n reset_dist <- function(x, click) {\n   nearPoints(x, click, allRows = TRUE, addDist = TRUE)$dist_\n }\n\n # scatterplot plot with point size dependent on click location\n scatter <- function(x, dists) {\n   x %>%\n     mutate(dist = dists) %>%\n     ggplot() +\n     geom_point(aes(mpg, hp, size = dist)) +\n     scale_size(range = c(6, 1))\n }\n\n ui <- fluidPage(\n   plotOutput(\"plot\", click = \"plot_click\")\n )\n\n server <- function(input, output) {\n   dist <- reactiveVal(rep(1, nrow(mtcars)))\n   observeEvent(\n     input$plot_click,\n     dist(reset_dist(mtcars, input$plot_click))\n   )\n\n   output$plot <- renderPlot(scatter(mtcars, dist()))\n }\n\n shinyApp(ui, server)\n \n\n\n\n\n\n\nThe reset_dist function uses nearPoints to compute the distance between each sample and the plot, each time the plot is clicked. The associated reactive value dist gets changed, which triggers scatterplot to run, and it is encoded using size in the downstream ggplot2 figure.\nWe can make the plot more interesting by outputting a table showing the original dataset. Using the same dist() call, we can sort the table by distance each time the plot is clicked.\n\n\nlibrary(tidyverse)\n library(shiny)\n mtcars <- add_rownames(mtcars)\n\n reset_dist <- function(x, click) {\n   nearPoints(x, click, allRows = TRUE, addDist = TRUE)$dist_\n }\n\n scatter <- function(x, dists) {\n   x %>%\n     mutate(dist = dists) %>%\n     ggplot() +\n     geom_point(aes(mpg, hp, size = dist)) +\n     scale_size(range = c(6, 1))\n }\n\n ui <- fluidPage(\n   plotOutput(\"plot\", click = \"plot_click\"),\n   dataTableOutput(\"table\")\n )\n\n server <- function(input, output) {\n   dist <- reactiveVal(rep(1, nrow(mtcars)))\n   observeEvent(\n     input$plot_click,\n     dist(reset_dist(mtcars, input$plot_click))\n   )\n\n   output$plot <- renderPlot(scatter(mtcars, dist()))\n   output$table <- renderDataTable({\n     mtcars %>%\n       mutate(dist = dist()) %>%\n       arrange(dist)\n   })\n }\n\n shinyApp(ui, server)\n \n\n\n\n\n\n\n\n\n\n",
    "preview": "posts/2022-02-16-week05-01/week05-01_files/figure-html5/unnamed-chunk-8-1.png",
    "last_modified": "2022-02-20T09:55:42-06:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-02-16-week05-02/",
    "title": "Graphical Queries: Brush Events",
    "description": "An introduction to brush events in Shiny.",
    "author": [
      {
        "name": "Kris Sankaran",
        "url": {}
      }
    ],
    "date": "2022-02-15",
    "categories": [],
    "contents": "\n\n\n\nReading, Recording, Rmarkdown\nClick events are useful for referring to individual samples. However, they are not ideal for referring to groups of samples. In this case, a useful type of plot input is a brush. This is a selection that can be defined by clicking and dragging over a region.\nIn shiny, brush events are treated similarly to click events. For example, to define a new brush input, we can set the brush argument to plotOutput.\n\n\nui <- fluidPage(\n   plotOutput(\"plot\", brush = \"plot_brush\")\n )\n \n\n\nJust like the click argument, the value \"plot_brush\" is an ID that can be used in the server. Also like in click events, we can setup an observer to change a reactive value every time a brush is drawn1. The general pattern is similar to what we had before,\n\nserver <- function(input, output) {\n  selected <- reactiveVal(initial value)\n  observeEvent(\n    input$plot_brush,\n    ... computation using get new_value ...\n    selected(new_value)\n  )\n\n  output$plot <- renderPlot(... use scatter() reactive val...)\n}\n\nThe example below is similar to the plot_click example from the previous notes. Instead of sorting points by proximity to the click, though, prints the subset of rows that have been currently brushed.\n\n\nlibrary(tidyverse)\n library(shiny)\n mtcars <- add_rownames(mtcars)\n\n reset_selection <- function(x, brush) {\n   brushedPoints(x, brush, allRows = TRUE)$selected_\n }\n\n scatter <- function(x, selected_) {\n   x %>%\n     mutate(selected_ = selected_) %>%\n     ggplot() +\n     geom_point(aes(mpg, hp, alpha = as.numeric(selected_))) +\n     scale_alpha(range = c(0.1, 1))\n }\n\n ui <- fluidPage(\n   plotOutput(\"plot\", brush = \"plot_brush\"),\n   dataTableOutput(\"table\")\n )\n\n server <- function(input, output) {\n   selected <- reactiveVal(rep(TRUE, nrow(mtcars)))\n   observeEvent(\n     input$plot_brush,\n     selected(reset_selection(mtcars, input$plot_brush))\n   )\n\n   output$plot <- renderPlot(scatter(mtcars, selected()))\n   output$table <- renderDataTable(filter(mtcars, selected()))\n }\n\n shinyApp(ui, server)\n \n\n\n\n\n\n\nIt is often useful to combine multi-view composition (i.e., faceting or compound figures) with dynamic queries. The basic idea is to (a) show different aspects of a dataset using different views, and then (b) link the views using dynamic queries. This strategy is sometimes called dynamic linking.\nThe example below implements dynamic linking with the penguins dataset. Brushing over either scatterplot highlights the corresponding points in the adjacent plot (it also updates the data table). This is a way of understanding structure beyond two dimensions. The implementation is similar to the brushing above, except that the reactive value selected() is called in two renderPlot contexts, leading to changes in both plots every time the brush is moved.\n\n\nlibrary(tidyverse)\n library(shiny)\n penguins <- read_csv(\"https://uwmadison.box.com/shared/static/ijh7iipc9ect1jf0z8qa2n3j7dgem1gh.csv\")\n\n reset_selection <- function(x, brush) {\n   brushedPoints(x, brush, allRows = TRUE)$selected_\n }\n\n scatter <- function(x, selected_, var1, var2) {\n   x %>%\n     mutate(selected_ = selected_) %>%\n     ggplot(aes_string(var1, var2)) +\n     geom_point(aes(alpha = as.numeric(selected_), col = species)) +\n     scale_alpha(range = c(0.1, 1))\n }\n\n ui <- fluidPage(\n   fluidRow(\n     column(6, plotOutput(\"scatter1\", brush = \"plot_brush\")),\n     column(6, plotOutput(\"scatter2\", brush = \"plot_brush\"))\n   ),\n   dataTableOutput(\"table\")\n )\n\n server <- function(input, output) {\n   selected <- reactiveVal(rep(TRUE, nrow(penguins)))\n   observeEvent(\n     input$plot_brush,\n     selected(reset_selection(penguins, input$plot_brush))\n   )\n\n   output$scatter1 <- renderPlot({\n     scatter(penguins, selected(), \"bill_length_mm\", \"bill_depth_mm\")\n   })\n   output$scatter2 <- renderPlot({\n     scatter(penguins, selected(), \"flipper_length_mm\", \"body_mass_g\")\n   })\n\n   output$table <- renderDataTable(filter(penguins, selected()))\n }\n\n shinyApp(ui, server)\n \n\n\n\n\n\n\n\nTechnically, the code only executes when the mouse lifts off the brush selection. Some visualizations will be able to call the updating code every time the mouse is moved with the brush selected. This creates a smoother experience.↩︎\n",
    "preview": "posts/2022-02-16-week05-02/week05-02_files/figure-html5/unnamed-chunk-4-1.png",
    "last_modified": "2022-02-20T09:55:44-06:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-02-16-week05-03/",
    "title": "Linked Brushing",
    "description": "More examples defining brush queries using Shiny and `ggplot2`.",
    "author": [
      {
        "name": "Kris Sankaran",
        "url": {}
      }
    ],
    "date": "2022-02-15",
    "categories": [],
    "contents": "\n\n\n\nReading, Recording, Rmarkdown\nThese notes provide more realistic examples of linked brushing. Though the visual design problems they address are more complex, they follow the same recipe described earlier,\nA reactiveVal is defined to track the currently selected samples.\nAn observeEvent is used to update the reactiveVal every time a plot is brushed.\nDownstream render contexts update plot and data table outputs whenever the reactiveVal is changed.\n\nThe first example implements linked brushing on the movie ratings dataset presented earlier. Before we had graphical queries, we used a slider to select movies within a user-specified time range. Our graphical alternative is to allow selections over a histogram of movie release dates within the dataset. Specifically, we will create an interactive version of the histogram below,\n\n\nlibrary(tidyverse)\n library(lubridate)\n\n movies <- read_csv(\"https://raw.githubusercontent.com/krisrs1128/stat479_s22/main/_posts/2022-02-10-week04-03/apps/data/movies.csv\") %>%\n   mutate(\n     date = as_date(Release_Date, format = \"%b %d %Y\"),\n     year = year(date),\n     Major_Genre = fct_explicit_na(Major_Genre)\n   )\n\n movies %>% \n   count(year) %>%\n   ggplot(aes(year, n)) +\n   geom_bar(stat = \"identity\", width = 1) +\n   scale_y_continuous(expand = c(0, 0))\n \n\n\n\nand when a subset of years of has been brushed, we will highlight the corresponding movies in the same kind of scatterplot used in the earlier, slider-based implementation.\n\n\nggplot(movies) +\n   geom_point(aes(Rotten_Tomatoes_Rating, IMDB_Rating))\n \n\n\n\nViewed more abstractly, we are going to use a brush to linking the histogram and the scatterplot views. We will be able to evaluate the change in a visualization (the scatterplot) after “conditioning” on a subset defined by a complementary view (the histogram). This is analogous to the penguins dataset example – only the form of the base plots has changed.\nThe main logic needed to link these views is given in the block below. The histogram plotOutput in the UI is given a brush which will be used to select years1. We use the selected reactive value to store a list of TRUE/FALSE’s indicating which movie falls into the currently brushed time range. Each time the brushed range is changed, the output$scatterplot and output$table outputs are regenerated, highlighting those movies that appear in the selected() list.\n\n\nui <- fluidPage(\n   fluidRow(\n     column(6, plotOutput(\"histogram\", brush = brushOpts(\"plot_brush\", direction = \"x\"))),\n     column(6, plotOutput(\"scatterplot\"))\n   ),\n   dataTableOutput(\"table\")\n )\n\n server <- function(input, output) {\n   selected <- reactiveVal(rep(TRUE, nrow(movies)))\n\n   observeEvent(\n     input$plot_brush,\n     selected(reset_selection(movies, input$plot_brush))\n   )\n\n   output$histogram <- renderPlot(histogram(movies))\n   output$scatterplot <- renderPlot(scatterplot(movies, selected()))\n   output$table <- renderDataTable(data_table(movies, selected()))\n }\n \n\n\nWe haven’t included the full code for histogram, scatterplot, and data_table, since they in and of themselves don’t require any logic for interactivity. You can try out the full code here, and a screenshot of the initial interface is below.\n\n\n\n\n\n\nA natural extension of the previous app is to allow brushing on both the histogram and the scatterplot. Brushing over the scatterplot would show the years during which the selected movies were released – this can be used to find out if very poorly or highly rated movies are associated with specific time ranges, for example.\nThe updated application is below. The main differences are that,\nThe scatterplot plotOutput now includes a brush.\nWe are passing in the reactive value of the selected() movies into the histogram as well.\n\n\nui <- fluidPage(\n   fluidRow(\n     column(6, plotOutput(\"histogram\", brush = brushOpts(\"plot_brush\", direction = \"x\"))),\n     column(6, plotOutput(\"scatterplot\", brush = \"plot_brush\"))\n   ),\n   dataTableOutput(\"table\")\n )\n\n server <- function(input, output) {\n   selected <- reactiveVal(rep(TRUE, nrow(movies)))\n\n   observeEvent(\n     input$plot_brush,\n     selected(reset_selection(movies, input$plot_brush))\n   )\n\n   output$histogram <- renderPlot(histogram(movies, selected()))\n   output$scatterplot <- renderPlot(scatterplot(movies, selected()))\n   output$table <- renderDataTable(data_table(movies, selected()))\n }\n\n shinyApp(ui, server)\n \n\n\nFor the scatterplot, we simply reduced the transparency for the movies that weren’t selected. We cannot do this for the histogram, though, because the movies are not directly represented in this plot, only their counts over time. Instead, our idea will be to draw two overlapping histograms. A static one in the background will represent the year distribution before any selection. A changing one in the foreground will be redrawn whenever the selected movies are changed. For example, the code below overlays two geom_bar layers, with one corresponding only to the first 500 movies in the dataset.\n\n\n  sub_counts <- movies[1:500, ] %>%\n     count(year)\n\n   movies %>%\n     count(year) %>%\n     ggplot(aes(year, n)) +\n     geom_bar(stat = \"identity\", fill = \"#d3d3d3\", width = 1) +\n     geom_bar(data = sub_counts, stat = \"identity\", width = 1) +\n     scale_y_continuous(expand = c(0, 0))\n \n\n\n\nCombining these ideas leads to the app here. A screenshot of the initial view is given below. Try running the code and brushing on both the scatterplot and the histogram. The especially interesting thing about this approach is that, without introducing any new screen elements, we’ve widened the class of questions of that can be answered. In a sense, we’ve increased the information density of the display – we can present more information without having to introduce any peripheral UI components or graphical marks.\nIn our last problem, we would like to use a dataset of flight delays to understand what characteristics of the flights make some more / less likely to be delayed. The basic difficulty is that there are many potentially relevant variables, and they might interact in ways that are not obvious in advance.\n\n\nlibrary(nycflights13)\nhead(flights)\n\n\n# A tibble: 6 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time\n  <int> <int> <int>    <int>          <int>     <dbl>    <int>\n1  2013     1     1      517            515         2      830\n2  2013     1     1      533            529         4      850\n3  2013     1     1      542            540         2      923\n4  2013     1     1      544            545        -1     1004\n5  2013     1     1      554            600        -6      812\n6  2013     1     1      554            558        -4      740\n# … with 12 more variables: sched_arr_time <int>, arr_delay <dbl>,\n#   carrier <chr>, flight <int>, tailnum <chr>, origin <chr>,\n#   dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#   minute <dbl>, time_hour <dttm>\n\nOur solution strategy will be to dynamically link complementary histograms. By brushing the histogram of delays time, we’ll be able to see the conditional distributions for other variables of interest. In principle, we could do this for every variable in the dataset, but for the example, we’ll focus on just the scheduled departure time and flight distance.\nThe UI in this case creates three separate histograms, each of which introduces a brush. We will plan on brushing one histogram at a time, which is then used to update overlays on each.\n\n\nui <- fluidPage(\n  fluidRow(\n    column(\n      6, \n      plotOutput(\"h1\", brush = brushOpts(\"plot_brush\", direction = \"x\"), height = 200),\n      plotOutput(\"h2\", brush = brushOpts(\"plot_brush\", direction = \"x\"), height = 200),\n      plotOutput(\"h3\", brush = brushOpts(\"plot_brush\", direction = \"x\"), height = 200)\n    ),\n    column(6, dataTableOutput(\"table\"))\n  ),\n)\n\n\n\nThe logic for drawing the overlays is encapsulated by the functions below. The bar_plot function draws two bar plots over one another, one referring to a global counts object of unchanging histogram bar heights. The second refers to the bar heights for the continually updated overlays. Notice that we use aes_string to use variable names encoded in strings. The plot_overlay function provides the histogram bar heights for variable v after brushing over the movies in selected_.\n\n\nbar_plot <- function(sub_flights, v) {\n   ggplot(counts[[v]], aes_string(v, \"n\")) +\n     geom_bar(fill = \"#d3d3d3\", stat = \"identity\") +\n     geom_bar(data = sub_flights, stat = \"identity\")\n }\n\n plot_overlay <- function(selected_, v) {\n   flights %>%\n     filter(selected_) %>%\n     count(.data[[v]]) %>%\n     bar_plot(v)\n }\n \n\n\nCode for the full application is linked here. Thanks to shiny’s reactiveVal and brushedPoints definitions, implementing interactivity only requires about 20 lines (starting from ui <- ... to the end). The rest of the code is used to draw new static plots depending on the current selection.\n\nNote that we restrict brush motion to the \\(x\\)-direction. This is because the \\(x\\) direction alone encodes year information, which we want to select.↩︎\n",
    "preview": "posts/2022-02-16-week05-03/week05-03_files/figure-html5/unnamed-chunk-2-1.png",
    "last_modified": "2022-02-20T09:55:45-06:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-02-16-week05-04/",
    "title": "Linking using Crosstalk",
    "description": "Linking in web-based visualizations.",
    "author": [
      {
        "name": "Kris Sankaran",
        "url": {}
      }
    ],
    "date": "2022-02-15",
    "categories": [],
    "contents": "\n\n\n\nReading, Recording, Rmarkdown\n\n\nlibrary(ggplot2)\nlibrary(plotly)\nlibrary(leaflet)\nlibrary(DT)\nlibrary(crosstalk)\n\n\n\nFor most graphical queries, the click and brush inputs implemented in Shiny will be sufficient. However, a basic limitation of shiny’s plotOutput is that it has to create views by generating static image files – it only creates the illusion of interactivity by rapidly changing the underlying files. In some cases, there will be so many points on the display each update will be slow and the fluidity of interaction will suffer.\nOne approach around this problem is to use a library that directly supports web-based plots. These plots can modify elements in place, without having to redraw and save the entire figure on each interaction. The crosstalk package gives one approach to linked views in this setting. We’ll only give an overview of it here, but the purpose of sharing it is so we have at least one example that we can refer to in case the Shiny approach becomes untenable.\nWe’ll study a problem about the dropoff in Chicago subway ridership after the start of the COVID-19 lockdowns. We have data on the weekday and weekend transit ridership at each subway station, along with the locations of the stations. We are curious about the extent of the change in ridership, along with features that might be responsible for some stations being differentially affected. The block below reads in this raw data,\n\n\ndownload.file(\"https://github.com/emilyriederer/demo-crosstalk/blob/master/data/stations.rds?raw=true\", \"stations.rds\")\n download.file(\"https://github.com/emilyriederer/demo-crosstalk/blob/master/data/trips_apr.rds?raw=true\", \"trips_apr.rds\")\n stations <- readRDS(\"stations.rds\")\n trips <- readRDS(\"trips_apr.rds\")\n \n\n\nThe crosstalk package implements a SharedData object. This is used to track selections across all the plots that refer to it. We can think of it as crosstalk’s analog of our earlier brushedPoints function. These objects are defined by calling SharedData$new() on the data.frame which will be used across views. The key argument provides a unique identifier that is used to match corresponding samples across all displays (notice that it uses ~ formula notation).\n\n\ntrips_ct <- SharedData$new(trips, key = ~station_id, group = \"stations\")\n \n\n\nLet’s see how this object can be used for linked brushing. We’ll first generate static ggplot2 objects giving (1) a view of weekday ridership in 2019 vs. 2020 and (2) a view of what proportion of 2019 ridership at the station took place on weekends.\n\n\np1 <- ggplot(trips_ct) +\n   geom_point(aes(year_2019_wday, year_2020_wday, name = station_name)) +\n   geom_abline(slope = 1, col = \"#0c0c0c\")\n\n p2 <- ggplot(trips_ct) +\n   geom_point(aes(prop_wend_2019, reorder(station_name, prop_wend_2019)), stat = \"identity\")\n \n\n\nGiven this ggplot2 base, we can build web-based plotly objects using the ggplotly command. The layout and highlight functions are specifying that we want user interactions to define brushes, not zoom events. The final bscols function allows us to place the views side by side. By brushing the two plots, we can see that those stations with the largest dropoff in riderships were those that were mostly used during the weekdays. This makes sense, considering many of the office workers in Chicago started working from home in 2020.\n\n\np1 <- ggplotly(p1, tooltip = \"station_name\") %>%\n   layout(dragmode = \"select\") %>%\n   highlight(on = \"plotly_selected\")\n\n p2 <- ggplotly(p2) %>%\n   layout(dragmode = \"select\", direction = \"v\") %>%\n   highlight(on = \"plotly_selected\")\n\n bscols(p1, p2)\n \n\n\n\n\n\n{\"x\":{\"data\":[{\"x\":[178635,156880,182063,78189,151203,29823,44407,87490,33295,225511,46700,70078,22471,62246,22242,40861,37357,24822,9235,18091],\"y\":[7726,6207,3699,2906,11262,2909,5115,8607,6922,38510,9792,15916,5311,19961,6617,13644,15908,8569,3201,7128],\"text\":[\"station_name: Quincy/Wells\",\"station_name: UIC-Halsted\",\"station_name: Merchandise Mart\",\"station_name: Southport\",\"station_name: Chicago/Franklin\",\"station_name: Ridgeland\",\"station_name: Cermak-McCormick Place\",\"station_name: Western-Brown\",\"station_name: Ashland-Orange\",\"station_name: Roosevelt\",\"station_name: 54th/Cermak\",\"station_name: Forest Park\",\"station_name: Garfield-South Elevated\",\"station_name: 63rd-Dan Ryan\",\"station_name: Pulaski-Cermak\",\"station_name: Central-Lake\",\"station_name: Pulaski-Forest Park\",\"station_name: Cicero-Lake\",\"station_name: King Drive\",\"station_name: Conservatory\"],\"key\":[\"40040\",\"40350\",\"40460\",\"40360\",\"40710\",\"40610\",\"41690\",\"41480\",\"41060\",\"41400\",\"40580\",\"40390\",\"40510\",\"40910\",\"40150\",\"40280\",\"40920\",\"40480\",\"41140\",\"41670\"],\"type\":\"scatter\",\"mode\":\"markers\",\"marker\":{\"autocolorscale\":false,\"color\":\"rgba(0,0,0,1)\",\"opacity\":1,\"size\":5.66929133858268,\"symbol\":\"circle\",\"line\":{\"width\":1.88976377952756,\"color\":\"rgba(0,0,0,1)\"}},\"hoveron\":\"points\",\"set\":\"stations\",\"showlegend\":false,\"xaxis\":\"x\",\"yaxis\":\"y\",\"hoverinfo\":\"text\",\"_isNestedKey\":false,\"frame\":null},{\"x\":[-1578.8,236324.8],\"y\":[-1578.8,236324.8],\"text\":\"\",\"type\":\"scatter\",\"mode\":\"lines\",\"line\":{\"width\":1.88976377952756,\"color\":\"rgba(12,12,12,1)\",\"dash\":\"solid\"},\"hoveron\":\"points\",\"showlegend\":false,\"xaxis\":\"x\",\"yaxis\":\"y\",\"hoverinfo\":\"text\",\"frame\":null}],\"layout\":{\"margin\":{\"t\":25.4977168949772,\"r\":7.30593607305936,\"b\":39.4520547945206,\"l\":54.7945205479452},\"plot_bgcolor\":\"rgba(235,235,235,1)\",\"paper_bgcolor\":\"rgba(255,255,255,1)\",\"font\":{\"color\":\"rgba(0,0,0,1)\",\"family\":\"\",\"size\":14.6118721461187},\"xaxis\":{\"domain\":[0,1],\"automargin\":true,\"type\":\"linear\",\"autorange\":false,\"range\":[-1578.8,236324.8],\"tickmode\":\"array\",\"ticktext\":[\"0\",\"50000\",\"100000\",\"150000\",\"200000\"],\"tickvals\":[0,50000,100000,150000,200000],\"categoryorder\":\"array\",\"categoryarray\":[\"0\",\"50000\",\"100000\",\"150000\",\"200000\"],\"nticks\":null,\"ticks\":\"outside\",\"tickcolor\":\"rgba(51,51,51,1)\",\"ticklen\":3.65296803652968,\"tickwidth\":0.66417600664176,\"showticklabels\":true,\"tickfont\":{\"color\":\"rgba(77,77,77,1)\",\"family\":\"\",\"size\":11.689497716895},\"tickangle\":-0,\"showline\":false,\"linecolor\":null,\"linewidth\":0,\"showgrid\":true,\"gridcolor\":\"rgba(255,255,255,1)\",\"gridwidth\":0.66417600664176,\"zeroline\":false,\"anchor\":\"y\",\"title\":{\"text\":\"year_2019_wday\",\"font\":{\"color\":\"rgba(0,0,0,1)\",\"family\":\"\",\"size\":14.6118721461187}},\"hoverformat\":\".2f\"},\"yaxis\":{\"domain\":[0,1],\"automargin\":true,\"type\":\"linear\",\"autorange\":false,\"range\":[1125.8,40290.2],\"tickmode\":\"array\",\"ticktext\":[\"10000\",\"20000\",\"30000\",\"40000\"],\"tickvals\":[10000,20000,30000,40000],\"categoryorder\":\"array\",\"categoryarray\":[\"10000\",\"20000\",\"30000\",\"40000\"],\"nticks\":null,\"ticks\":\"outside\",\"tickcolor\":\"rgba(51,51,51,1)\",\"ticklen\":3.65296803652968,\"tickwidth\":0.66417600664176,\"showticklabels\":true,\"tickfont\":{\"color\":\"rgba(77,77,77,1)\",\"family\":\"\",\"size\":11.689497716895},\"tickangle\":-0,\"showline\":false,\"linecolor\":null,\"linewidth\":0,\"showgrid\":true,\"gridcolor\":\"rgba(255,255,255,1)\",\"gridwidth\":0.66417600664176,\"zeroline\":false,\"anchor\":\"x\",\"title\":{\"text\":\"year_2020_wday\",\"font\":{\"color\":\"rgba(0,0,0,1)\",\"family\":\"\",\"size\":14.6118721461187}},\"hoverformat\":\".2f\"},\"shapes\":[{\"type\":\"rect\",\"fillcolor\":null,\"line\":{\"color\":null,\"width\":0,\"linetype\":[]},\"yref\":\"paper\",\"xref\":\"paper\",\"x0\":0,\"x1\":1,\"y0\":0,\"y1\":1}],\"showlegend\":false,\"legend\":{\"bgcolor\":\"rgba(255,255,255,1)\",\"bordercolor\":\"transparent\",\"borderwidth\":1.88976377952756,\"font\":{\"color\":\"rgba(0,0,0,1)\",\"family\":\"\",\"size\":11.689497716895}},\"hovermode\":\"closest\",\"barmode\":\"relative\",\"dragmode\":\"select\"},\"config\":{\"doubleClick\":\"reset\",\"modeBarButtonsToAdd\":[\"hoverclosest\",\"hovercompare\"],\"showSendToCloud\":false},\"source\":\"A\",\"attrs\":{\"99603372cc3b\":{\"x\":{},\"y\":{},\"name\":{},\"type\":\"scatter\"},\"996035be4fe0\":{\"intercept\":{},\"slope\":{}}},\"cur_data\":\"99603372cc3b\",\"visdat\":{\"99603372cc3b\":[\"function (y) \",\"x\"],\"996035be4fe0\":[\"function (y) \",\"x\"]},\"highlight\":{\"on\":\"plotly_selected\",\"off\":\"plotly_deselect\",\"persistent\":false,\"dynamic\":false,\"color\":null,\"selectize\":false,\"defaultValues\":null,\"opacityDim\":0.2,\"selected\":{\"opacity\":1},\"debounce\":0,\"ctGroups\":[\"stations\"]},\"shinyEvents\":[\"plotly_hover\",\"plotly_click\",\"plotly_selected\",\"plotly_relayout\",\"plotly_brushed\",\"plotly_brushing\",\"plotly_clickannotation\",\"plotly_doubleclick\",\"plotly_deselect\",\"plotly_afterplot\",\"plotly_sunburstclick\"],\"base_url\":\"https://plot.ly\"},\"evals\":[],\"jsHooks\":[]}\n\n\n{\"x\":{\"data\":[{\"x\":[0.0532382870468518,0.0785694567624239,0.0646503670747558,0.143397094590153,0.0970151927762649,0.0893184316599487,0.193875142955688,0.150219511247523,0.141925673934333,0.182513530463026,0.132373432419879,0.114181340142332,0.157569168478668,0.186507573480403,0.159442197951703,0.16275305302844,0.208487827616162,0.174059162146874,0.156081513296171,0.193266443701226],\"y\":[1,3,2,9,5,4,19,10,8,16,7,6,12,17,13,14,20,15,11,18],\"text\":[\"prop_wend_2019: 0.05323829<br />reorder(station_name, prop_wend_2019): Quincy/Wells\",\"prop_wend_2019: 0.07856946<br />reorder(station_name, prop_wend_2019): UIC-Halsted\",\"prop_wend_2019: 0.06465037<br />reorder(station_name, prop_wend_2019): Merchandise Mart\",\"prop_wend_2019: 0.14339709<br />reorder(station_name, prop_wend_2019): Southport\",\"prop_wend_2019: 0.09701519<br />reorder(station_name, prop_wend_2019): Chicago/Franklin\",\"prop_wend_2019: 0.08931843<br />reorder(station_name, prop_wend_2019): Ridgeland\",\"prop_wend_2019: 0.19387514<br />reorder(station_name, prop_wend_2019): Cermak-McCormick Place\",\"prop_wend_2019: 0.15021951<br />reorder(station_name, prop_wend_2019): Western-Brown\",\"prop_wend_2019: 0.14192567<br />reorder(station_name, prop_wend_2019): Ashland-Orange\",\"prop_wend_2019: 0.18251353<br />reorder(station_name, prop_wend_2019): Roosevelt\",\"prop_wend_2019: 0.13237343<br />reorder(station_name, prop_wend_2019): 54th/Cermak\",\"prop_wend_2019: 0.11418134<br />reorder(station_name, prop_wend_2019): Forest Park\",\"prop_wend_2019: 0.15756917<br />reorder(station_name, prop_wend_2019): Garfield-South Elevated\",\"prop_wend_2019: 0.18650757<br />reorder(station_name, prop_wend_2019): 63rd-Dan Ryan\",\"prop_wend_2019: 0.15944220<br />reorder(station_name, prop_wend_2019): Pulaski-Cermak\",\"prop_wend_2019: 0.16275305<br />reorder(station_name, prop_wend_2019): Central-Lake\",\"prop_wend_2019: 0.20848783<br />reorder(station_name, prop_wend_2019): Pulaski-Forest Park\",\"prop_wend_2019: 0.17405916<br />reorder(station_name, prop_wend_2019): Cicero-Lake\",\"prop_wend_2019: 0.15608151<br />reorder(station_name, prop_wend_2019): King Drive\",\"prop_wend_2019: 0.19326644<br />reorder(station_name, prop_wend_2019): Conservatory\"],\"key\":[\"40040\",\"40350\",\"40460\",\"40360\",\"40710\",\"40610\",\"41690\",\"41480\",\"41060\",\"41400\",\"40580\",\"40390\",\"40510\",\"40910\",\"40150\",\"40280\",\"40920\",\"40480\",\"41140\",\"41670\"],\"type\":\"scatter\",\"mode\":\"markers\",\"marker\":{\"autocolorscale\":false,\"color\":\"rgba(0,0,0,1)\",\"opacity\":1,\"size\":5.66929133858268,\"symbol\":\"circle\",\"line\":{\"width\":1.88976377952756,\"color\":\"rgba(0,0,0,1)\"}},\"hoveron\":\"points\",\"set\":\"stations\",\"showlegend\":false,\"xaxis\":\"x\",\"yaxis\":\"y\",\"hoverinfo\":\"text\",\"_isNestedKey\":false,\"frame\":null}],\"layout\":{\"margin\":{\"t\":25.4977168949772,\"r\":7.30593607305936,\"b\":39.4520547945206,\"l\":160},\"plot_bgcolor\":\"rgba(235,235,235,1)\",\"paper_bgcolor\":\"rgba(255,255,255,1)\",\"font\":{\"color\":\"rgba(0,0,0,1)\",\"family\":\"\",\"size\":14.6118721461187},\"xaxis\":{\"domain\":[0,1],\"automargin\":true,\"type\":\"linear\",\"autorange\":false,\"range\":[0.0454758100183863,0.216250304644628],\"tickmode\":\"array\",\"ticktext\":[\"0.05\",\"0.10\",\"0.15\",\"0.20\"],\"tickvals\":[0.05,0.1,0.15,0.2],\"categoryorder\":\"array\",\"categoryarray\":[\"0.05\",\"0.10\",\"0.15\",\"0.20\"],\"nticks\":null,\"ticks\":\"outside\",\"tickcolor\":\"rgba(51,51,51,1)\",\"ticklen\":3.65296803652968,\"tickwidth\":0.66417600664176,\"showticklabels\":true,\"tickfont\":{\"color\":\"rgba(77,77,77,1)\",\"family\":\"\",\"size\":11.689497716895},\"tickangle\":-0,\"showline\":false,\"linecolor\":null,\"linewidth\":0,\"showgrid\":true,\"gridcolor\":\"rgba(255,255,255,1)\",\"gridwidth\":0.66417600664176,\"zeroline\":false,\"anchor\":\"y\",\"title\":{\"text\":\"prop_wend_2019\",\"font\":{\"color\":\"rgba(0,0,0,1)\",\"family\":\"\",\"size\":14.6118721461187}},\"hoverformat\":\".2f\"},\"yaxis\":{\"domain\":[0,1],\"automargin\":true,\"type\":\"linear\",\"autorange\":false,\"range\":[0.4,20.6],\"tickmode\":\"array\",\"ticktext\":[\"Quincy/Wells\",\"Merchandise Mart\",\"UIC-Halsted\",\"Ridgeland\",\"Chicago/Franklin\",\"Forest Park\",\"54th/Cermak\",\"Ashland-Orange\",\"Southport\",\"Western-Brown\",\"King Drive\",\"Garfield-South Elevated\",\"Pulaski-Cermak\",\"Central-Lake\",\"Cicero-Lake\",\"Roosevelt\",\"63rd-Dan Ryan\",\"Conservatory\",\"Cermak-McCormick Place\",\"Pulaski-Forest Park\"],\"tickvals\":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\"categoryorder\":\"array\",\"categoryarray\":[\"Quincy/Wells\",\"Merchandise Mart\",\"UIC-Halsted\",\"Ridgeland\",\"Chicago/Franklin\",\"Forest Park\",\"54th/Cermak\",\"Ashland-Orange\",\"Southport\",\"Western-Brown\",\"King Drive\",\"Garfield-South Elevated\",\"Pulaski-Cermak\",\"Central-Lake\",\"Cicero-Lake\",\"Roosevelt\",\"63rd-Dan Ryan\",\"Conservatory\",\"Cermak-McCormick Place\",\"Pulaski-Forest Park\"],\"nticks\":null,\"ticks\":\"outside\",\"tickcolor\":\"rgba(51,51,51,1)\",\"ticklen\":3.65296803652968,\"tickwidth\":0.66417600664176,\"showticklabels\":true,\"tickfont\":{\"color\":\"rgba(77,77,77,1)\",\"family\":\"\",\"size\":11.689497716895},\"tickangle\":-0,\"showline\":false,\"linecolor\":null,\"linewidth\":0,\"showgrid\":true,\"gridcolor\":\"rgba(255,255,255,1)\",\"gridwidth\":0.66417600664176,\"zeroline\":false,\"anchor\":\"x\",\"title\":{\"text\":\"reorder(station_name, prop_wend_2019)\",\"font\":{\"color\":\"rgba(0,0,0,1)\",\"family\":\"\",\"size\":14.6118721461187}},\"hoverformat\":\".2f\"},\"shapes\":[{\"type\":\"rect\",\"fillcolor\":null,\"line\":{\"color\":null,\"width\":0,\"linetype\":[]},\"yref\":\"paper\",\"xref\":\"paper\",\"x0\":0,\"x1\":1,\"y0\":0,\"y1\":1}],\"showlegend\":false,\"legend\":{\"bgcolor\":\"rgba(255,255,255,1)\",\"bordercolor\":\"transparent\",\"borderwidth\":1.88976377952756,\"font\":{\"color\":\"rgba(0,0,0,1)\",\"family\":\"\",\"size\":11.689497716895}},\"hovermode\":\"closest\",\"barmode\":\"relative\",\"dragmode\":\"select\",\"direction\":\"v\"},\"config\":{\"doubleClick\":\"reset\",\"modeBarButtonsToAdd\":[\"hoverclosest\",\"hovercompare\"],\"showSendToCloud\":false},\"source\":\"A\",\"attrs\":{\"99602db80f71\":{\"x\":{},\"y\":{},\"type\":\"scatter\"}},\"cur_data\":\"99602db80f71\",\"visdat\":{\"99602db80f71\":[\"function (y) \",\"x\"]},\"highlight\":{\"on\":\"plotly_selected\",\"off\":\"plotly_deselect\",\"persistent\":false,\"dynamic\":false,\"color\":null,\"selectize\":false,\"defaultValues\":null,\"opacityDim\":0.2,\"selected\":{\"opacity\":1},\"debounce\":0,\"ctGroups\":[\"stations\"]},\"shinyEvents\":[\"plotly_hover\",\"plotly_click\",\"plotly_selected\",\"plotly_relayout\",\"plotly_brushed\",\"plotly_brushing\",\"plotly_clickannotation\",\"plotly_doubleclick\",\"plotly_deselect\",\"plotly_afterplot\",\"plotly_sunburstclick\"],\"base_url\":\"https://plot.ly\"},\"evals\":[],\"jsHooks\":[]}\n\n\n\nThis crosstalk approach works with more than plotly-derived plots. In the block below, we also generate a map (using the leaflet package) and a data table (using the DT package). The views are all synchronized because they refer to the same station_id key in SharedData objects. This visualization confirms our intuition that those stations with the largest drop-off in ridership are those that are downtown.\n\n\nstations_ct <- SharedData$new(stations, key = ~station_id, group = \"stations\")\ndt <- datatable(trips_ct)\nlf <- leaflet(stations_ct) %>% \n  addTiles() %>% \n  addMarkers()\n\nbscols(p1, p2, lf, dt, widths = rep(6, 4))\n\n\n\n\n\n\n{\"x\":{\"data\":[{\"x\":[178635,156880,182063,78189,151203,29823,44407,87490,33295,225511,46700,70078,22471,62246,22242,40861,37357,24822,9235,18091],\"y\":[7726,6207,3699,2906,11262,2909,5115,8607,6922,38510,9792,15916,5311,19961,6617,13644,15908,8569,3201,7128],\"text\":[\"station_name: Quincy/Wells\",\"station_name: UIC-Halsted\",\"station_name: Merchandise Mart\",\"station_name: Southport\",\"station_name: Chicago/Franklin\",\"station_name: Ridgeland\",\"station_name: Cermak-McCormick Place\",\"station_name: Western-Brown\",\"station_name: Ashland-Orange\",\"station_name: Roosevelt\",\"station_name: 54th/Cermak\",\"station_name: Forest Park\",\"station_name: Garfield-South Elevated\",\"station_name: 63rd-Dan Ryan\",\"station_name: Pulaski-Cermak\",\"station_name: Central-Lake\",\"station_name: Pulaski-Forest Park\",\"station_name: Cicero-Lake\",\"station_name: King Drive\",\"station_name: Conservatory\"],\"key\":[\"40040\",\"40350\",\"40460\",\"40360\",\"40710\",\"40610\",\"41690\",\"41480\",\"41060\",\"41400\",\"40580\",\"40390\",\"40510\",\"40910\",\"40150\",\"40280\",\"40920\",\"40480\",\"41140\",\"41670\"],\"type\":\"scatter\",\"mode\":\"markers\",\"marker\":{\"autocolorscale\":false,\"color\":\"rgba(0,0,0,1)\",\"opacity\":1,\"size\":5.66929133858268,\"symbol\":\"circle\",\"line\":{\"width\":1.88976377952756,\"color\":\"rgba(0,0,0,1)\"}},\"hoveron\":\"points\",\"set\":\"stations\",\"showlegend\":false,\"xaxis\":\"x\",\"yaxis\":\"y\",\"hoverinfo\":\"text\",\"_isNestedKey\":false,\"frame\":null},{\"x\":[-1578.8,236324.8],\"y\":[-1578.8,236324.8],\"text\":\"\",\"type\":\"scatter\",\"mode\":\"lines\",\"line\":{\"width\":1.88976377952756,\"color\":\"rgba(12,12,12,1)\",\"dash\":\"solid\"},\"hoveron\":\"points\",\"showlegend\":false,\"xaxis\":\"x\",\"yaxis\":\"y\",\"hoverinfo\":\"text\",\"frame\":null}],\"layout\":{\"margin\":{\"t\":25.4977168949772,\"r\":7.30593607305936,\"b\":39.4520547945206,\"l\":54.7945205479452},\"plot_bgcolor\":\"rgba(235,235,235,1)\",\"paper_bgcolor\":\"rgba(255,255,255,1)\",\"font\":{\"color\":\"rgba(0,0,0,1)\",\"family\":\"\",\"size\":14.6118721461187},\"xaxis\":{\"domain\":[0,1],\"automargin\":true,\"type\":\"linear\",\"autorange\":false,\"range\":[-1578.8,236324.8],\"tickmode\":\"array\",\"ticktext\":[\"0\",\"50000\",\"100000\",\"150000\",\"200000\"],\"tickvals\":[0,50000,100000,150000,200000],\"categoryorder\":\"array\",\"categoryarray\":[\"0\",\"50000\",\"100000\",\"150000\",\"200000\"],\"nticks\":null,\"ticks\":\"outside\",\"tickcolor\":\"rgba(51,51,51,1)\",\"ticklen\":3.65296803652968,\"tickwidth\":0.66417600664176,\"showticklabels\":true,\"tickfont\":{\"color\":\"rgba(77,77,77,1)\",\"family\":\"\",\"size\":11.689497716895},\"tickangle\":-0,\"showline\":false,\"linecolor\":null,\"linewidth\":0,\"showgrid\":true,\"gridcolor\":\"rgba(255,255,255,1)\",\"gridwidth\":0.66417600664176,\"zeroline\":false,\"anchor\":\"y\",\"title\":{\"text\":\"year_2019_wday\",\"font\":{\"color\":\"rgba(0,0,0,1)\",\"family\":\"\",\"size\":14.6118721461187}},\"hoverformat\":\".2f\"},\"yaxis\":{\"domain\":[0,1],\"automargin\":true,\"type\":\"linear\",\"autorange\":false,\"range\":[1125.8,40290.2],\"tickmode\":\"array\",\"ticktext\":[\"10000\",\"20000\",\"30000\",\"40000\"],\"tickvals\":[10000,20000,30000,40000],\"categoryorder\":\"array\",\"categoryarray\":[\"10000\",\"20000\",\"30000\",\"40000\"],\"nticks\":null,\"ticks\":\"outside\",\"tickcolor\":\"rgba(51,51,51,1)\",\"ticklen\":3.65296803652968,\"tickwidth\":0.66417600664176,\"showticklabels\":true,\"tickfont\":{\"color\":\"rgba(77,77,77,1)\",\"family\":\"\",\"size\":11.689497716895},\"tickangle\":-0,\"showline\":false,\"linecolor\":null,\"linewidth\":0,\"showgrid\":true,\"gridcolor\":\"rgba(255,255,255,1)\",\"gridwidth\":0.66417600664176,\"zeroline\":false,\"anchor\":\"x\",\"title\":{\"text\":\"year_2020_wday\",\"font\":{\"color\":\"rgba(0,0,0,1)\",\"family\":\"\",\"size\":14.6118721461187}},\"hoverformat\":\".2f\"},\"shapes\":[{\"type\":\"rect\",\"fillcolor\":null,\"line\":{\"color\":null,\"width\":0,\"linetype\":[]},\"yref\":\"paper\",\"xref\":\"paper\",\"x0\":0,\"x1\":1,\"y0\":0,\"y1\":1}],\"showlegend\":false,\"legend\":{\"bgcolor\":\"rgba(255,255,255,1)\",\"bordercolor\":\"transparent\",\"borderwidth\":1.88976377952756,\"font\":{\"color\":\"rgba(0,0,0,1)\",\"family\":\"\",\"size\":11.689497716895}},\"hovermode\":\"closest\",\"barmode\":\"relative\",\"dragmode\":\"select\"},\"config\":{\"doubleClick\":\"reset\",\"modeBarButtonsToAdd\":[\"hoverclosest\",\"hovercompare\"],\"showSendToCloud\":false},\"source\":\"A\",\"attrs\":{\"99603372cc3b\":{\"x\":{},\"y\":{},\"name\":{},\"type\":\"scatter\"},\"996035be4fe0\":{\"intercept\":{},\"slope\":{}}},\"cur_data\":\"99603372cc3b\",\"visdat\":{\"99603372cc3b\":[\"function (y) \",\"x\"],\"996035be4fe0\":[\"function (y) \",\"x\"]},\"highlight\":{\"on\":\"plotly_selected\",\"off\":\"plotly_deselect\",\"persistent\":false,\"dynamic\":false,\"color\":null,\"selectize\":false,\"defaultValues\":null,\"opacityDim\":0.2,\"selected\":{\"opacity\":1},\"debounce\":0,\"ctGroups\":[\"stations\"]},\"shinyEvents\":[\"plotly_hover\",\"plotly_click\",\"plotly_selected\",\"plotly_relayout\",\"plotly_brushed\",\"plotly_brushing\",\"plotly_clickannotation\",\"plotly_doubleclick\",\"plotly_deselect\",\"plotly_afterplot\",\"plotly_sunburstclick\"],\"base_url\":\"https://plot.ly\"},\"evals\":[],\"jsHooks\":[]}\n\n\n{\"x\":{\"data\":[{\"x\":[0.0532382870468518,0.0785694567624239,0.0646503670747558,0.143397094590153,0.0970151927762649,0.0893184316599487,0.193875142955688,0.150219511247523,0.141925673934333,0.182513530463026,0.132373432419879,0.114181340142332,0.157569168478668,0.186507573480403,0.159442197951703,0.16275305302844,0.208487827616162,0.174059162146874,0.156081513296171,0.193266443701226],\"y\":[1,3,2,9,5,4,19,10,8,16,7,6,12,17,13,14,20,15,11,18],\"text\":[\"prop_wend_2019: 0.05323829<br />reorder(station_name, prop_wend_2019): Quincy/Wells\",\"prop_wend_2019: 0.07856946<br />reorder(station_name, prop_wend_2019): UIC-Halsted\",\"prop_wend_2019: 0.06465037<br />reorder(station_name, prop_wend_2019): Merchandise Mart\",\"prop_wend_2019: 0.14339709<br />reorder(station_name, prop_wend_2019): Southport\",\"prop_wend_2019: 0.09701519<br />reorder(station_name, prop_wend_2019): Chicago/Franklin\",\"prop_wend_2019: 0.08931843<br />reorder(station_name, prop_wend_2019): Ridgeland\",\"prop_wend_2019: 0.19387514<br />reorder(station_name, prop_wend_2019): Cermak-McCormick Place\",\"prop_wend_2019: 0.15021951<br />reorder(station_name, prop_wend_2019): Western-Brown\",\"prop_wend_2019: 0.14192567<br />reorder(station_name, prop_wend_2019): Ashland-Orange\",\"prop_wend_2019: 0.18251353<br />reorder(station_name, prop_wend_2019): Roosevelt\",\"prop_wend_2019: 0.13237343<br />reorder(station_name, prop_wend_2019): 54th/Cermak\",\"prop_wend_2019: 0.11418134<br />reorder(station_name, prop_wend_2019): Forest Park\",\"prop_wend_2019: 0.15756917<br />reorder(station_name, prop_wend_2019): Garfield-South Elevated\",\"prop_wend_2019: 0.18650757<br />reorder(station_name, prop_wend_2019): 63rd-Dan Ryan\",\"prop_wend_2019: 0.15944220<br />reorder(station_name, prop_wend_2019): Pulaski-Cermak\",\"prop_wend_2019: 0.16275305<br />reorder(station_name, prop_wend_2019): Central-Lake\",\"prop_wend_2019: 0.20848783<br />reorder(station_name, prop_wend_2019): Pulaski-Forest Park\",\"prop_wend_2019: 0.17405916<br />reorder(station_name, prop_wend_2019): Cicero-Lake\",\"prop_wend_2019: 0.15608151<br />reorder(station_name, prop_wend_2019): King Drive\",\"prop_wend_2019: 0.19326644<br />reorder(station_name, prop_wend_2019): Conservatory\"],\"key\":[\"40040\",\"40350\",\"40460\",\"40360\",\"40710\",\"40610\",\"41690\",\"41480\",\"41060\",\"41400\",\"40580\",\"40390\",\"40510\",\"40910\",\"40150\",\"40280\",\"40920\",\"40480\",\"41140\",\"41670\"],\"type\":\"scatter\",\"mode\":\"markers\",\"marker\":{\"autocolorscale\":false,\"color\":\"rgba(0,0,0,1)\",\"opacity\":1,\"size\":5.66929133858268,\"symbol\":\"circle\",\"line\":{\"width\":1.88976377952756,\"color\":\"rgba(0,0,0,1)\"}},\"hoveron\":\"points\",\"set\":\"stations\",\"showlegend\":false,\"xaxis\":\"x\",\"yaxis\":\"y\",\"hoverinfo\":\"text\",\"_isNestedKey\":false,\"frame\":null}],\"layout\":{\"margin\":{\"t\":25.4977168949772,\"r\":7.30593607305936,\"b\":39.4520547945206,\"l\":160},\"plot_bgcolor\":\"rgba(235,235,235,1)\",\"paper_bgcolor\":\"rgba(255,255,255,1)\",\"font\":{\"color\":\"rgba(0,0,0,1)\",\"family\":\"\",\"size\":14.6118721461187},\"xaxis\":{\"domain\":[0,1],\"automargin\":true,\"type\":\"linear\",\"autorange\":false,\"range\":[0.0454758100183863,0.216250304644628],\"tickmode\":\"array\",\"ticktext\":[\"0.05\",\"0.10\",\"0.15\",\"0.20\"],\"tickvals\":[0.05,0.1,0.15,0.2],\"categoryorder\":\"array\",\"categoryarray\":[\"0.05\",\"0.10\",\"0.15\",\"0.20\"],\"nticks\":null,\"ticks\":\"outside\",\"tickcolor\":\"rgba(51,51,51,1)\",\"ticklen\":3.65296803652968,\"tickwidth\":0.66417600664176,\"showticklabels\":true,\"tickfont\":{\"color\":\"rgba(77,77,77,1)\",\"family\":\"\",\"size\":11.689497716895},\"tickangle\":-0,\"showline\":false,\"linecolor\":null,\"linewidth\":0,\"showgrid\":true,\"gridcolor\":\"rgba(255,255,255,1)\",\"gridwidth\":0.66417600664176,\"zeroline\":false,\"anchor\":\"y\",\"title\":{\"text\":\"prop_wend_2019\",\"font\":{\"color\":\"rgba(0,0,0,1)\",\"family\":\"\",\"size\":14.6118721461187}},\"hoverformat\":\".2f\"},\"yaxis\":{\"domain\":[0,1],\"automargin\":true,\"type\":\"linear\",\"autorange\":false,\"range\":[0.4,20.6],\"tickmode\":\"array\",\"ticktext\":[\"Quincy/Wells\",\"Merchandise Mart\",\"UIC-Halsted\",\"Ridgeland\",\"Chicago/Franklin\",\"Forest Park\",\"54th/Cermak\",\"Ashland-Orange\",\"Southport\",\"Western-Brown\",\"King Drive\",\"Garfield-South Elevated\",\"Pulaski-Cermak\",\"Central-Lake\",\"Cicero-Lake\",\"Roosevelt\",\"63rd-Dan Ryan\",\"Conservatory\",\"Cermak-McCormick Place\",\"Pulaski-Forest Park\"],\"tickvals\":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],\"categoryorder\":\"array\",\"categoryarray\":[\"Quincy/Wells\",\"Merchandise Mart\",\"UIC-Halsted\",\"Ridgeland\",\"Chicago/Franklin\",\"Forest Park\",\"54th/Cermak\",\"Ashland-Orange\",\"Southport\",\"Western-Brown\",\"King Drive\",\"Garfield-South Elevated\",\"Pulaski-Cermak\",\"Central-Lake\",\"Cicero-Lake\",\"Roosevelt\",\"63rd-Dan Ryan\",\"Conservatory\",\"Cermak-McCormick Place\",\"Pulaski-Forest Park\"],\"nticks\":null,\"ticks\":\"outside\",\"tickcolor\":\"rgba(51,51,51,1)\",\"ticklen\":3.65296803652968,\"tickwidth\":0.66417600664176,\"showticklabels\":true,\"tickfont\":{\"color\":\"rgba(77,77,77,1)\",\"family\":\"\",\"size\":11.689497716895},\"tickangle\":-0,\"showline\":false,\"linecolor\":null,\"linewidth\":0,\"showgrid\":true,\"gridcolor\":\"rgba(255,255,255,1)\",\"gridwidth\":0.66417600664176,\"zeroline\":false,\"anchor\":\"x\",\"title\":{\"text\":\"reorder(station_name, prop_wend_2019)\",\"font\":{\"color\":\"rgba(0,0,0,1)\",\"family\":\"\",\"size\":14.6118721461187}},\"hoverformat\":\".2f\"},\"shapes\":[{\"type\":\"rect\",\"fillcolor\":null,\"line\":{\"color\":null,\"width\":0,\"linetype\":[]},\"yref\":\"paper\",\"xref\":\"paper\",\"x0\":0,\"x1\":1,\"y0\":0,\"y1\":1}],\"showlegend\":false,\"legend\":{\"bgcolor\":\"rgba(255,255,255,1)\",\"bordercolor\":\"transparent\",\"borderwidth\":1.88976377952756,\"font\":{\"color\":\"rgba(0,0,0,1)\",\"family\":\"\",\"size\":11.689497716895}},\"hovermode\":\"closest\",\"barmode\":\"relative\",\"dragmode\":\"select\",\"direction\":\"v\"},\"config\":{\"doubleClick\":\"reset\",\"modeBarButtonsToAdd\":[\"hoverclosest\",\"hovercompare\"],\"showSendToCloud\":false},\"source\":\"A\",\"attrs\":{\"99602db80f71\":{\"x\":{},\"y\":{},\"type\":\"scatter\"}},\"cur_data\":\"99602db80f71\",\"visdat\":{\"99602db80f71\":[\"function (y) \",\"x\"]},\"highlight\":{\"on\":\"plotly_selected\",\"off\":\"plotly_deselect\",\"persistent\":false,\"dynamic\":false,\"color\":null,\"selectize\":false,\"defaultValues\":null,\"opacityDim\":0.2,\"selected\":{\"opacity\":1},\"debounce\":0,\"ctGroups\":[\"stations\"]},\"shinyEvents\":[\"plotly_hover\",\"plotly_click\",\"plotly_selected\",\"plotly_relayout\",\"plotly_brushed\",\"plotly_brushing\",\"plotly_clickannotation\",\"plotly_doubleclick\",\"plotly_deselect\",\"plotly_afterplot\",\"plotly_sunburstclick\"],\"base_url\":\"https://plot.ly\"},\"evals\":[],\"jsHooks\":[]}\n\n\n{\"x\":{\"options\":{\"crs\":{\"crsClass\":\"L.CRS.EPSG3857\",\"code\":null,\"proj4def\":null,\"projectedBounds\":null,\"options\":{}}},\"calls\":[{\"method\":\"addSelect\",\"args\":[\"stations\"]},{\"method\":\"addTiles\",\"args\":[\"//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",null,null,{\"minZoom\":0,\"maxZoom\":18,\"tileSize\":256,\"subdomains\":\"abc\",\"errorTileUrl\":\"\",\"tms\":false,\"noWrap\":false,\"zoomOffset\":0,\"zoomReverse\":false,\"opacity\":1,\"zIndex\":1,\"detectRetina\":false,\"attribution\":\"&copy; <a href=\\\"http://openstreetmap.org\\\">OpenStreetMap<\\/a> contributors, <a href=\\\"http://creativecommons.org/licenses/by-sa/2.0/\\\">CC-BY-SA<\\/a>\"}]},{\"method\":\"addMarkers\",\"args\":[[41.878723,41.853732,41.887389,41.875474,41.943744,41.874257,41.888969,41.886519,41.795172,41.85177331,41.887159,41.89681,41.780536,41.873797,41.839234,41.78013,41.8673865,41.966163,41.884904,41.853115],[-87.63374,-87.724311,-87.76565,-87.649707,-87.663619,-87.817318,-87.633924,-87.744698,-87.618327,-87.75669201,-87.783661,-87.635924,-87.630952,-87.725663,-87.665317,-87.615546,-87.626996,-87.688502,-87.716523,-87.626402],null,null,null,{\"interactive\":true,\"draggable\":false,\"keyboard\":true,\"title\":\"\",\"alt\":\"\",\"zIndexOffset\":0,\"opacity\":1,\"riseOnHover\":false,\"riseOffset\":250},null,null,null,null,null,{\"interactive\":false,\"permanent\":false,\"direction\":\"auto\",\"opacity\":1,\"offset\":[0,0],\"textsize\":\"10px\",\"textOnly\":false,\"className\":\"\",\"sticky\":true},{\"ctKey\":[\"40040\",\"40150\",\"40280\",\"40350\",\"40360\",\"40390\",\"40460\",\"40480\",\"40510\",\"40580\",\"40610\",\"40710\",\"40910\",\"40920\",\"41060\",\"41140\",\"41400\",\"41480\",\"41670\",\"41690\"],\"ctGroup\":\"stations\"}]}],\"limits\":{\"lat\":[41.78013,41.966163],\"lng\":[-87.817318,-87.615546]}},\"evals\":[],\"jsHooks\":[]}\n\n\n{\"x\":{\"crosstalkOptions\":{\"key\":[\"40040\",\"40350\",\"40460\",\"40360\",\"40710\",\"40610\",\"41690\",\"41480\",\"41060\",\"41400\",\"40580\",\"40390\",\"40510\",\"40910\",\"40150\",\"40280\",\"40920\",\"40480\",\"41140\",\"41670\"],\"group\":\"stations\"},\"filter\":\"none\",\"vertical\":false,\"data\":[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\"],[\"Quincy/Wells\",\"UIC-Halsted\",\"Merchandise Mart\",\"Southport\",\"Chicago/Franklin\",\"Ridgeland\",\"Cermak-McCormick Place\",\"Western-Brown\",\"Ashland-Orange\",\"Roosevelt\",\"54th/Cermak\",\"Forest Park\",\"Garfield-South Elevated\",\"63rd-Dan Ryan\",\"Pulaski-Cermak\",\"Central-Lake\",\"Pulaski-Forest Park\",\"Cicero-Lake\",\"King Drive\",\"Conservatory\"],[\"40040\",\"40350\",\"40460\",\"40360\",\"40710\",\"40610\",\"41690\",\"41480\",\"41060\",\"41400\",\"40580\",\"40390\",\"40510\",\"40910\",\"40150\",\"40280\",\"40920\",\"40480\",\"41140\",\"41670\"],[178635,156880,182063,78189,151203,29823,44407,87490,33295,225511,46700,70078,22471,62246,22242,40861,37357,24822,9235,18091],[10045,13377,12584,13089,16245,2925,10680,15466,5507,50348,7125,9033,4203,14271,4219,7943,9840,5231,1708,4334],[7726,6207,3699,2906,11262,2909,5115,8607,6922,38510,9792,15916,5311,19961,6617,13644,15908,8569,3201,7128],[959,2039,710,692,2063,625,1293,2016,1623,9800,1948,3307,1366,5850,1705,3257,4885,2129,805,1923],[188680,170257,194647,91278,167448,32748,55087,102956,38802,275859,53825,79111,26674,76517,26461,48804,47197,30053,10943,22425],[8685,8246,4409,3598,13325,3534,6408,10623,8545,48310,11740,19223,6677,25811,8322,16901,20793,10698,4006,9051],[-0.953969684121263,-0.951567336438443,-0.977348738999317,-0.960581958412761,-0.920423056710143,-0.892085012825211,-0.883674914226587,-0.896820000777031,-0.779779392814803,-0.824874301726607,-0.781885740826753,-0.757012299174577,-0.749681337632151,-0.662676268018872,-0.685499414232266,-0.653696418326367,-0.559442337436701,-0.644028882307923,-0.6339212281824,-0.596387959866221],[0.0532382870468518,0.0785694567624239,0.0646503670747558,0.143397094590153,0.0970151927762649,0.0893184316599487,0.193875142955688,0.150219511247523,0.141925673934333,0.182513530463026,0.132373432419879,0.114181340142332,0.157569168478668,0.186507573480403,0.159442197951703,0.16275305302844,0.208487827616162,0.174059162146874,0.156081513296171,0.193266443701226],[0.11042026482441,0.247271404317245,0.161034248128827,0.192329071706504,0.154821763602251,0.176853423882286,0.201779026217228,0.189776899181022,0.189935634874195,0.202856551438626,0.165928449744463,0.17203350153462,0.204582896510409,0.226647553368719,0.204878634943523,0.192710490503521,0.234934833838311,0.199009160590765,0.200948577134299,0.212462711302618]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th> <\\/th>\\n      <th>station_name<\\/th>\\n      <th>station_id<\\/th>\\n      <th>year_2019_wday<\\/th>\\n      <th>year_2019_wend<\\/th>\\n      <th>year_2020_wday<\\/th>\\n      <th>year_2020_wend<\\/th>\\n      <th>year_2019<\\/th>\\n      <th>year_2020<\\/th>\\n      <th>pct_change<\\/th>\\n      <th>prop_wend_2019<\\/th>\\n      <th>prop_wend_2020<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"columnDefs\":[{\"className\":\"dt-right\",\"targets\":[3,4,5,6,7,8,9,10,11]},{\"orderable\":false,\"targets\":0}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false},\"selection\":{\"mode\":\"multiple\",\"selected\":null,\"target\":\"row\",\"selectable\":null}},\"evals\":[],\"jsHooks\":[]}\n\n\n\n\n\n\n",
    "preview": {},
    "last_modified": "2022-02-20T09:56:29-06:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-02-10-week04-01/",
    "title": "Elements of a Shiny App",
    "description": "Vocabulary used by R Shiny Library, and a few example apps.",
    "author": [
      {
        "name": "Kris Sankaran",
        "url": {}
      }
    ],
    "date": "2022-02-14",
    "categories": [],
    "contents": "\n\n\n\nReading, Recording, Rmarkdown\nAll Shiny apps are made up from the same few building blocks. These notes review the main types of blocks. When reading code from more complex apps, it can be helpful to try to classify pieces of the code into these types of blocks.\nThe highest level breakdown of Shiny app code is between ui and server components. The ui controls what the app looks like. It stands for “User Interface.” The server controls what the app does. For example, the app below defines a title and textbox where users can type. But it does not do anything, since the server is empty.\n\n\nlibrary(shiny)\n\n ui <- fluidPage(\n   titlePanel(\"Hello!\"),\n   textInput(\"name\", \"Enter your name\")  # first arg is ID, second is label\n )\n\n server <- function(input, output) {}\n app <- shinyApp(ui, server)\n \n\n\n\n\n\nFigure 1: Screenshot of the app defined above.\n\n\n\nNote that in this an all the remaining Shiny examples, I’ve just included a screenshot of the app. If you copy and run the code into a R file, you will be able to run the app interactively. You can also just download the code directly from the course github page.\nThe UI elements can be further broken down into Inputs, Outputs, and Descriptors1, all grouped together by an organizing layout function. Inputs are UI elements that users can manipulate to prompt certain types of computation. Outputs are parts of the interface that reflects the result of a server computation. Descriptors are parts of the page that aren’t involved in computation, but which provide narrative structure and guide the user.\nFor example, in the toy app above, titlePage is a descriptor providing some title text. textInput is an input element allowing users to enter text. fluidPage is a layout function that arranges these elements on a continuous page (some other layout functions are sidebarLayout, navbarPage, flowLayout, …)\nAn important point is that all input and output elements must be given a unique ID. This is always the first argument of a *Input or *Output function defined in Shiny. The ID tags are how different parts of the application are able to refer to one another. For example, if we wanted to refer to the text the user entered in the application above, we could refer to the name ID.\nLet’s see how to (1) make user inputs cause some sort of computation and (2) have the result of that computation appear to the user. For (1), we will add a renderText element to the server. All render* functions do two things,\nThey make inputs from the ui available for computation.\nThey generate HTML code that allows the results of the computation to appear in a UI output.\nFor (2), we will add a textOutput element to the ui layout defined above. Let’s look at the code,\n\n\nlibrary(shiny)\n\n ui <- fluidPage(\n   titlePanel(\"Hello!\"),\n   textInput(\"name\", \"Enter your name\"),\n   textOutput(\"printed_name\")\n )\n\n server <- function(input, output) {\n   output$printed_name <- renderText({\n     paste0(\"Welcome to shiny, \", input$name, \"!\")\n   })\n }\n\n app <- shinyApp(ui, server)\n \n\n\n\n\n\nThere are a few points worth noting. First, the renderText component was able to refer to the value entered in the textbox using input$name. This was possible because name was the ID that we gave to the textInput component. It also would not have worked if we had used input$text outside of a render* function: this is what we mean by the render* functions making the UI inputs available for computation. Finally, we were able to refer to the rendered output in the UI by adding a textOutput component. By giving this component the id printed_name, we were able to tell it to look into the server for a rendered output named printed_name and fill it in.\nAn even deeper idea is that the code did not simply run linearly, from top of the script to the bottom. If that were all the code did, then it would have run once at the beginning, and it would never have updated when you entered your name. Instead, it ran every time you typed into the textbox. This is the “reactive programming” paradigm, and it is what makes interactive visualization possible. renderText knows to rerun every time something is entered into the name text input, because we told it to depend on input$name. We will explore the idea of reactivity in more depth in the next lecture, but for now, just remember that the order in which code is executed is not simply determined by the order of lines in a file.\nLet’s look at a few more examples, just to get a feel for things. The app below updates a plot of random normal variables given a mean specified by the user. We’ve introduced a new type of input, a numericInput, which captures numbers. We’ve also added a new output, plotOutput, allowing with its accompanying renderer, renderPlot (remember, UI outputs are always paired with server renderers).\n\n\nlibrary(shiny)\n library(tidyverse)\n\n ui <- fluidPage(\n   titlePanel(\"Random Normals\"),\n   numericInput(\"mean\", \"Enter the mean\", 0), # 0 is the default\n   plotOutput(\"histogram\")\n )\n\n server <- function(input, output) {\n   output$histogram <- renderPlot({\n     data.frame(values = rnorm(100, input$mean)) %>%\n       ggplot() +\n         geom_histogram(aes(values))\n   })\n }\n\n app <- shinyApp(ui, server)\n \n\n\n\n\n\nWe can make the plot depend on several inputs. The code below allows the user to change the total number of data points and the variance, this time using slider inputs. I recommend taking a look at different inputs on the shiny cheatsheet, though be aware that there are many extensions built by the community.\n\n\nlibrary(shiny)\n library(tidyverse)\n\n ui <- fluidPage(\n   titlePanel(\"Random Normals\"),\n   numericInput(\"mean\", \"Enter the mean\", 0),\n   sliderInput(\"n\", \"Enter the number of samples\", 500, min=1, max=2000),\n   sliderInput(\"sigma\", \"Enter the standard deviation\", 1, min=.1, max=5),\n   plotOutput(\"histogram\")\n )\n\n server <- function(input, output) {\n   output$histogram <- renderPlot({\n     data.frame(values = rnorm(input$n, input$mean, input$sigma)) %>%\n       ggplot() +\n         geom_histogram(aes(values), bins = 100) +\n         xlim(-10, 10)\n   })\n }\n\n app <- shinyApp(ui, server)\n \n\n\n\n\n\nWe can also make the app return several outputs, not just a plot. The code below attempts to print the data along in addition to the histogram, but it makes a crucial mistake (can you spot it?).\n\n\nlibrary(shiny)\n library(tidyverse)\n\n ui <- fluidPage(\n   titlePanel(\"Random Normals\"),\n   numericInput(\"mean\", \"Enter the mean\", 0),\n   sliderInput(\"n\", \"Enter the number of samples\", 500, min=1, max=2000),\n   sliderInput(\"sigma\", \"Enter the standard deviation\", 1, min=.1, max=5),\n   plotOutput(\"histogram\"),\n   dataTableOutput(\"dt\")\n )\n\n server <- function(input, output) {\n   output$histogram <- renderPlot({\n     data.frame(values = rnorm(input$n, input$mean, input$sigma)) %>%\n       ggplot() +\n         geom_histogram(aes(values), bins = 100) +\n         xlim(-10, 10)\n   })\n\n   output$dt <- renderDataTable({\n     data.frame(values = rnorm(input$n, input$mean, input$sigma))\n   })\n }\n\n app <- shinyApp(ui, server)\n \n\n\n\n\n\nThe issue is that this code reruns rnorm for each output. So, even though the interfaces suggests that the printed samples are the same as the ones in the histogram, they are actually different. To resolve this, we need a way of storing an intermediate computation which (1) depends on the inputs but (2) feeds into several outputs. Whenever we encounter this need, we can use a reactive expression. It is a type of server element that depends on the input and can be referred to directly by outputs, which call the reactive expression like a function. For example, the code below generates the random normal samples a single time, using the samples() reactive expression.\n\n\nlibrary(shiny)\n library(tidyverse)\n\n ui <- fluidPage(\n   titlePanel(\"Random Normals\"),\n   numericInput(\"mean\", \"Enter the mean\", 0),\n   sliderInput(\"n\", \"Enter the number of samples\", 500, min=1, max=2000),\n   sliderInput(\"sigma\", \"Enter the standard deviation\", 1, min=.1, max=5),\n   plotOutput(\"histogram\"),\n   dataTableOutput(\"dt\")\n )\n\n server <- function(input, output) {\n   samples <- reactive({\n     data.frame(values = rnorm(input$n, input$mean, input$sigma))\n   })\n\n   output$histogram <- renderPlot({\n       ggplot(samples()) +\n         geom_histogram(aes(values), bins = 100) +\n         xlim(-10, 10)\n   })\n\n   output$dt <- renderDataTable(samples())\n }\n\n app <- shinyApp(ui, server)\n \n\n\n\n\n\nFinally, a good practice is to move as much non-app related code to separate functions. This makes the flow of the app more transparent. The clearer the delineation between “computation required for individual app components” and “relationship across components,” the easier the code will be to understand and extend.\n\n\nlibrary(shiny)\n library(tidyverse)\n\n ### Functions within app components\n generate_data <- function(n, mean, sigma) {\n   data.frame(values = rnorm(n, mean, sigma))\n }\n\n histogram_fun <- function(df) {\n   ggplot(df) +\n     geom_histogram(aes(values), bins = 100) +\n     xlim(-10, 10)\n }\n\n ### Defines the app\n ui <- fluidPage(\n   titlePanel(\"Random Normals\"),\n   numericInput(\"mean\", \"Enter the mean\", 0),\n   sliderInput(\"n\", \"Enter the number of samples\", 500, min=1, max=2000),\n   sliderInput(\"sigma\", \"Enter the standard deviation\", 1, min=.1, max=5),\n   plotOutput(\"histogram\"),\n   dataTableOutput(\"dt\")\n )\n\n server <- function(input, output) {\n   samples <- reactive({\n     generate_data(input$n, input$mean, input$sigma)\n   })\n   output$histogram <- renderPlot(histogram_fun(samples()))\n   output$dt <- renderDataTable(samples())\n }\n\n app <- shinyApp(ui, server)\n \n\n\n\n\n\n\nI like to use these names to keep everything organized, but they are not official, and you do not need to memorize this.↩︎\n",
    "preview": "posts/2022-02-10-week04-01/app1.png",
    "last_modified": "2022-02-20T09:55:35-06:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-02-06-week03-04/",
    "title": "Patchwork",
    "description": "Implementing compound figures in R",
    "author": [
      {
        "name": "Kris Sankaran",
        "url": {}
      }
    ],
    "date": "2022-02-11",
    "categories": [],
    "contents": "\n\n\n\nReading, Recording, Rmarkdown\nIn the last set of notes we discussed principles for designing effective compound figures. In these notes, we’ll review the patchwork R package, which can be used to implement compound figures.\nThis package creates a simple syntax for combining figures,\np1 + p2 concatenates two figures horizontally\np1 / p2 concatenates two figures vertically\nThis idea is simple, but becomes very powerful once we realize that we can define a whole algebra on plot layouts,\np1 + p2 + p3 concatenates three figures horizontally\np1 / p2 / p3 concatenates three figures vertically\n(p1 + p2) / p3 Concatenates the first two figures horizontally, and places the third below both.\n…\n\nBefore we illustrate the use of this package, let’s read in the athletes data from the previous notes. The code below constructs the three component plots that we want to combine. Though it looks like a lot of code, it’s just because we are making several plots and styling each one of them. Conceptually, this is the same type of ggplot2 code that we have been using all semester – the only difference is that we save all the figure objects into one list, instead of printing them right away.\n\n\nlibrary(tidyverse)\n library(patchwork)\n\n athletes <- read_csv(\"data/athletes.csv\") %>%\n   filter(sport %in% c(\"basketball\", \"field\", \"rowing\", \"swimming\", \"tennis\", \"track (400m)\")) %>%\n   mutate(sex = recode(sex, \"m\" = \"male\", \"f\" = \"female\"))\n\n p <- list()\n p[[\"bar\"]] <- ggplot(count(athletes, sex)) +\n   geom_bar(aes(sex, n, fill = sex), stat = \"identity\") +\n   scale_y_continuous(expand = c(0, 0)) +\n   scale_fill_brewer(palette = \"Set1\") +\n   labs(y = \"number\")\n\n p[[\"scatter\"]] <- ggplot(athletes) +\n   geom_point(aes(rcc, wcc, col = sex)) +\n   scale_color_brewer(palette = \"Set1\") +\n   theme(legend.position = \"none\") +\n   labs(x = \"RBC count\", y = \"WBC Count\")\n\n p[[\"box\"]] <- ggplot(athletes) +\n   geom_boxplot(aes(sport, pcBfat, col = sex, fill = sex), alpha = 0.5) +\n   scale_color_brewer(palette = \"Set1\") +\n   scale_fill_brewer(palette = \"Set1\") +\n   theme(legend.position = \"none\") +\n   labs(y = \"% body fat\", x = NULL)\n \n\n\nNow, we use patchwork to combine the subplots using the different combinations discussed above.\n\n\np[[\"bar\"]] + p[[\"scatter\"]] + p[[\"box\"]]\n \n\n\np[[\"bar\"]] / p[[\"scatter\"]] / p[[\"box\"]]\n \n\n\n(p[[\"bar\"]] + p[[\"scatter\"]]) / p[[\"box\"]]\n \n\n\n\nA corollary of using the same encodings across panels is that it should be possible to share legends across the entire compound figure. This is most concisely done by setting plot_layout(legend = \"collect\"). For example, compare the athlete physiology dataset with and without the collected legends,\n\n\n(p[[\"bar\"]] + p[[\"scatter\"]] + theme(legend.position = \"left\")) / p[[\"box\"]] # turns legends back on\n \n\n\n\nThe version with the legends collected is given below.\n\n\n(p[[\"bar\"]] + p[[\"scatter\"]]) / p[[\"box\"]] +\n       plot_layout(guides = \"collect\") &\n       plot_annotation(theme = theme(legend.position = \"bottom\"))\n \n\n\n\nFor annotation, we can add a title to each figure individually using ggtitle(), before they are combined into the compound figure. The size and font of the titles can be adjusted by using the theme(title = element_text(...)) option. For example, the code below adds the a - c titles for each subpanel.\n\n\np[[\"bar\"]] <- p[[\"bar\"]] + ggtitle(\"a\")\n p[[\"scatter\"]] <- p[[\"scatter\"]] + ggtitle(\"b\")\n p[[\"box\"]] <- p[[\"box\"]] + ggtitle(\"c\")\n\n (p[[\"bar\"]] + p[[\"scatter\"]]) / p[[\"box\"]] +\n   plot_layout(guides = \"collect\") &\n   plot_annotation(theme = theme(legend.position = \"bottom\", title = element_text(size = 10)))\n \n\n\n\nPatchwork handles alignment in the background, but sometimes we might want to have control over the relative sizes of different panels. For this, we can again use the plot_layout function, this time using the height and width arguments. For example, the two examples change the height and widths of the first component in the layout.\n\n\n    (p[[\"bar\"]] + p[[\"scatter\"]] + plot_layout(widths = c(1, 3))) / p[[\"box\"]] +\n      plot_layout(guides = \"collect\")\n\n\n\n    (p[[\"bar\"]] + p[[\"scatter\"]]) / p[[\"box\"]] +\n      plot_layout(guides = \"collect\", heights = c(1, 3))\n\n\n\n\n\n\n\n",
    "preview": "posts/2022-02-06-week03-04/week03-04_files/figure-html5/unnamed-chunk-3-1.png",
    "last_modified": "2022-02-20T09:54:42-06:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-02-06-week03-03/",
    "title": "Compound Figures",
    "description": "Showing different variables across subpanels.",
    "author": [
      {
        "name": "Kris Sankaran",
        "url": {}
      }
    ],
    "date": "2022-02-10",
    "categories": [],
    "contents": "\n\n\n\nReading, Recording, Rmarkdown\nFaceting is useful whenever we want different rows of the data to appear in different panels. What if we want to compare different columns, or work with several datasets? A more general alternative is to use compound plots. The idea is to construct plots separately and then combine them only at the very end.\nThe main advantage of compound plots is that individual panels can be tailored to specific visual comparisons, but relationships across panels can also be studied. For example, the plot below shows change in the total number and composition of undergraduate majors over the last few decades. In principle, the same information could be communicated using a stacked area plot (geom_area). However, comparing the percentages for 1970 and 2015 is much more straightforward using a line plot, and we can still see changes in the overall number of degrees using the area plot.\n\n\n\nFor reference, here is a non-compound display of the same information.\n\n\n\nThere are a few considerations that can substantially improve the quality of a compound plot,\nConsistent visual encodings for shared variables\nClear, but unobtrusive annotation\nProper alignment in figure baselines\nWe will discuss each point separately.\nThe figures below are compound plots of a dataset of athlete physiology. They are very similar, but the second is better because it enforces a more strict consistency in encodings across panels. Specifically, the male / female variable is (1) encoded using the same color scheme across all panels and (2) ordered so that female repeatedly appears on the right of male.\n\n\n\nThe improved, visually consistent approach is given below.\n\n\n\nEffective annotation can be used to refer to different subpanels of the data without drawing too much attention to itself. Labels should be visible but subtle – not too large, similar fonts as the figures, and logically ordered ((a) on top left). A nice heuristic is to think of these annotations like page numbers. They are useful for making references, but aren’t something that is actively read.\n\n\n\nFor alignment, we will want figure baselines / borders to be consistent. Misalignment can be distracting. This is primarily a problem when compound plots are made from manually. If we follow the programmatic approaches discussed in the next lecture, we won’t have this issue.\n\n\n\n\n\n\n",
    "preview": "posts/2022-02-06-week03-03/week03-03_files/figure-html5/unnamed-chunk-2-1.png",
    "last_modified": "2022-02-20T09:54:40-06:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-01-23-week01-02/",
    "title": "A Vocabulary of Marks",
    "description": "Examples of encodings and sequential refinement of a plot.",
    "author": [
      {
        "name": "Kris Sankaran",
        "url": {}
      }
    ],
    "date": "2022-01-29",
    "categories": [],
    "contents": "\n\n\n\nReading, Recording, Rmarkdown\nThe choice of encodings can have a strong effect on (1) the types of comparisons that a visualization suggests and (2) the chance that readers leave with complete and accurate conclucions. With this in mind, it’s worthwhile to develop a rich vocabulary of potential visual encodings.\nSo, let’s look at a few different types of encodings available in ggplot2. Before we get started, let’s load up the libraries that will be used in these notes. ggplot2 is our plotting library. readr is used to read data files from a web link, and dplyr is useful for some of the data manipulations below (we dive into it deeply in Week 2).\n\n\nlibrary(readr)\nlibrary(ggplot2)\nlibrary(dplyr)\ntheme_set(theme_bw()) # create a simpler default theme\n\n\n\nPoint Marks\nLet’s read in the gapminder dataset, which describes the changes in standard of living around the world over the last few decades. The %>% “pipe” operator takes the output of the previous command as input to the next one – it is useful for chains of commands where the intermediate results are not needed. The mutate command makes sure that the country group variable is treated as a categorical, and not numeric, variable.\n\n\ngapminder <- read_csv(\"https://uwmadison.box.com/shared/static/dyz0qohqvgake2ghm4ngupbltkzpqb7t.csv\", col_types = cols()) %>%\n  mutate(cluster = as.factor(cluster))  # specify that cluster is nominal\ngap2000 <- filter(gapminder, year == 2000) # keep only year 2000\n\n\n\nPoint marks can encode data fields using their \\(x\\) and \\(y\\) positions, color, size, and shape. Below, each mark is a country, and we’re using shape and the \\(y\\) position to distinguish between country clusters.\n\n\nggplot(gap2000) +\n  geom_point(aes(x = fertility, y = cluster, shape = cluster))\n\n\n\n\nSince the first two arguments in aes are always the x and y positions, we can omit it from our command. The code below produces the exact same plot (try it!).\n\n\nggplot(gap2000) +\n  geom_point(aes(fertility, cluster, shape = cluster))\n\n\n\nWe can specify different types of shapes using the shape parameter outside of the aes encoding.\n\n\nggplot(gap2000) +\n  geom_point(aes(fertility, cluster), shape = 15)\n\n\n\n\nBar Marks\nBar marks let us associate a continuous field with a nominal one.\n\n\nggplot(gap2000) +\n  geom_bar(aes(country, pop), stat = \"identity\")\n\n\n\n\nThe plot above is messy – it would not be appropriate for a publication or presentation. The grid lines associated with each bar are distracting. Further, the axis labels are all running over one another. For the first issue, we can customize the theme of the plot. Note that we don’t have to memorize the names of these arguments, since they should autocomplete when pressing tab (we just need to memorize the first few letters).\n\n\nggplot(gap2000) +\n  geom_bar(aes(country, pop), stat = \"identity\") +\n  theme(panel.grid.major.x = element_blank())\n\n\n\n\nFor the second issue, one approach is to turn the labels on their side, again by customizing the theme.\n\n\nggplot(gap2000) +\n  geom_bar(aes(country, pop), stat = \"identity\") +\n  theme(\n    axis.text.x = element_text(angle = 90),\n    panel.grid.major.x = element_blank()\n  )\n\n\n\n\nAn approach I like better is to turn the bars on their side. This way, readers don’t have to tilt their heads to read the country names.\n\n\nggplot(gap2000) +\n  geom_bar(aes(pop, country), stat = \"identity\") +\n  theme(panel.grid.major.y = element_blank()) # note change from x to y\n\n\n\n\nI’m also going to remove the small tick marks associated with every name, again because it seems distracting.\n\n\nggplot(gap2000) +\n  geom_bar(aes(pop, country), stat = \"identity\") +\n  theme(\n    panel.grid.major.y = element_blank(),\n    axis.ticks = element_blank() # remove tick marks\n  )\n\n\n\n\nTo make comparisons between countries with similar populations easier, we can order them by population (alphabetical ordering is not that meaningful). To compare clusters, we can color in the bars.\n\n\nggplot(gap2000) +\n   geom_bar(aes(pop, reorder(country, pop), fill = cluster), stat = \"identity\") +\n   theme(\n     axis.ticks = element_blank(),\n     panel.grid.major.y = element_blank()\n   )\n \n\n\n\nWe’ve been spending a lot of time on this plot. This is because I want to emphasize that a visualization is not just something we can get just by memorizing some magic (programming) incantation. Instead, it is something worth critically engaging with and refining, in a similar way that we would refine an essay or speech.\nPhilosophy aside, there are still a few points that need to be improved in this figure,\nThe axis titles are not meaningful.\nThere is a strange gap between the left hand edge of the plot and the start of the bars.\nI would also prefer if the bars were exactly touching one another, without the small vertical gap.\nThe scientific notation for population size is unnecessarily technical.\nThe color scheme is a bit boring.\nI’ll address each of these in a separate code block, with comments on the parts that are different. First, improving the axis titles,\n\n\nggplot(gap2000) +\n   geom_bar(aes(pop, reorder(country, pop), fill = cluster), stat = \"identity\") +\n   labs(x = \"Population\", y = \"Country\", fill = \"Country Group\") + # add better titles\n   theme(\n     axis.ticks = element_blank(),\n     panel.grid.major.y = element_blank()\n   )\n \n\n\n\nNow we remove the gap. I learned this trick by googling it – there is no shame in doing this! A wise friend of mine once shared, “I am not a programming expert, just an expert at StackOverflow.”\n\n\nggplot(gap2000) +\n   geom_bar(aes(pop, reorder(country, pop), fill = cluster), stat = \"identity\") +\n   scale_x_continuous(expand = c(0, 0, 0.1, 0.1)) + # remove space to the axis\n   labs(x = \"Population\", y = \"Country\", fill = \"Country Group\") + \n   theme(\n     axis.text.y = element_text(size = 6),\n     axis.ticks = element_blank(),\n     panel.grid.major.y = element_blank()\n   )\n \n\n\n\nNow, removing the gaps between bars.\n\n\nggplot(gap2000) +\n   geom_bar(\n     aes(pop, reorder(country, pop), fill = cluster),\n     width = 1, stat = \"identity\" # increase width of bars\n   ) +\n   scale_x_continuous(expand = c(0, 0, 0.1, 0.1)) +\n   labs(x = \"Population\", y = \"Country\", fill = \"Country Group\", color = \"Country Group\") +\n   theme(\n     axis.ticks = element_blank(),\n     panel.grid.major.y = element_blank()\n   )\n \n\n\n\nNow, we remove scientific notation,\n\n\nggplot(gap2000) +\n   geom_bar(\n     aes(pop, reorder(country, pop), fill = cluster),\n     width = 1, stat = \"identity\"\n   ) +\n   scale_x_continuous(label = scales::label_number_si(), expand = c(0, 0, 0.1, 0.1)) + # remove scientific notation. scales::comma() is also useful.\n   labs(x = \"Population\", y = \"Country\", fill = \"Country Group\", color = \"Country Group\") +\n   theme(\n     axis.ticks = element_blank(),\n     panel.grid.major.y = element_blank()\n   )\n \n\n\n\nFinally, we customize the colors. I often like to look up neat colors on color.adobe.com, iwanthue or colorhexa, but there are dozens of similar colorpicker sites out there.\n\n\nggplot(gap2000) +\n   geom_bar(\n     aes(pop, reorder(country, pop), fill = cluster),\n     width = 1, stat = \"identity\"\n   ) +\n   scale_x_continuous(label = scales::label_number_si(), expand = c(0, 0, 0.1, 0.1)) +\n   scale_fill_manual(values = c(\"#80BFA2\", \"#7EB6D9\", \"#3E428C\", \"#D98BB6\", \"#BF2E21\", \"#F23A29\")) +\n   labs(x = \"Population\", y = \"Country\", fill = \"Country Group\", color = \"Country Group\") +\n   theme(\n     axis.ticks = element_blank(),\n     panel.grid.major.y = element_blank()\n   )\n \n\n\n\nThis seems like a lot of work for just a lowly bar plot! But I think it’s amazing customizable the figure is – we can give it our own sense of style. With a bit of practice, these sorts of modifications will become second nature, and it won’t be necessary to keep track of all the intermediate code. And really, even though we spent some time on this plot, there are still many things that could be interesting to experiment with, like font styles, background appearance, maybe even splitting the countries into two panels.\nIn the plot above, each bar is anchored at 0. Instead, we could have each bar encode two continuous values, a left and right. To illustrate, let’s compare the minimum and maximimum life expectancies within each country cluster. We’ll need to create a new data.frame with just the summary information. For this, we group_by each cluster, so that a summarise call finds the minimum and maximum life expectancies restricted to each cluster. We’ll discuss the group_by + summarise pattern in detail next week.\n\n\n# find summary statistics\nlife_ranges <- gap2000 %>%\n  group_by(cluster) %>%\n  summarise(\n    min_life = min(life_expect),\n    max_life = max(life_expect)\n  )\n\n# look at a few rows\nhead(life_ranges)\n\n\n# A tibble: 6 × 3\n  cluster min_life max_life\n  <fct>      <dbl>    <dbl>\n1 0           42.1     63.6\n2 1           70.5     80.6\n3 2           43.4     53.4\n4 3           58.1     79.8\n5 4           66.7     82  \n6 5           57.0     79.7\n\nggplot(life_ranges) +\n  geom_segment(\n    aes(min_life, reorder(cluster, max_life), xend = max_life, yend = cluster, col = cluster),\n    size = 5,\n  ) +\n  scale_color_manual(values = c(\"#80BFA2\", \"#7EB6D9\", \"#3E428C\", \"#D98BB6\", \"#BF2E21\", \"#F23A29\")) +\n  labs(x = \"Minimum and Maximum Expected Span\", col = \"Country Group\", y = \"Country Group\") +\n  xlim(0, 85) # otherwise would only range from 42 to 82\n\n\n\n\nLine Marks\nLine marks are useful for comparing changes. Our eyes naturally focus on rates of change when we see lines. Below, we’ll plot the fertility over time, colored in by country cluster. The group argument is useful for ensuring each country gets its own line; if we removed it, ggplot2 would become confused by the fact that the same x (year) values are associated with multiple y’s (fertility rates).\n\n\nggplot(gapminder) +\n  geom_line(\n    aes(year, fertility, col = cluster, group = country),\n      alpha = 0.7, size = 0.9\n  ) +\n  scale_x_continuous(expand = c(0, 0)) +  # same trick of removing gap\n  scale_color_manual(values = c(\"#80BFA2\", \"#7EB6D9\", \"#3E428C\", \"#D98BB6\", \"#BF2E21\", \"#F23A29\"))\n\n\n\n\nArea Marks\nArea marks have a flavor of both bar and line marks. The filled area supports absolute comparisons, while the changes in shape suggest derivatives.\n\n\npopulation_sums <- gapminder %>%\n  group_by(year, cluster) %>%\n  summarise(total_pop = sum(pop))\nhead(population_sums)\n\n\n# A tibble: 6 × 3\n# Groups:   year [1]\n   year cluster total_pop\n  <dbl> <fct>       <dbl>\n1  1955 0       495927174\n2  1955 1       360609771\n3  1955 2        60559800\n4  1955 3       355392405\n5  1955 4       854125031\n6  1955 5        56064015\n\nggplot(population_sums) +\n  geom_area(aes(year, total_pop, fill = cluster)) +\n  scale_y_continuous(expand = c(0, 0, .1, .1), label = scales::label_number_si()) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_fill_manual(values = c(\"#80BFA2\", \"#7EB6D9\", \"#3E428C\", \"#D98BB6\", \"#BF2E21\", \"#F23A29\"))\n\n\n\n\nJust like in bar marks, we don’t necessarily need to anchor the \\(y\\)-axis at 0. For example, here the bottom and top of each area mark is given by the 30% and 70% quantiles of population within each country cluster.\n\n\npopulation_ranges <- gapminder %>%\n  group_by(year, cluster) %>%\n  summarise(min_pop = quantile(pop, 0.3), max_pop = quantile(pop, 0.7))\nhead(population_ranges)\n\n\n# A tibble: 6 × 4\n# Groups:   year [1]\n   year cluster   min_pop   max_pop\n  <dbl> <fct>       <dbl>     <dbl>\n1  1955 0       40880121. 83941368.\n2  1955 1        4532940  25990229.\n3  1955 2        6600426. 17377594.\n4  1955 3        2221139   8671500 \n5  1955 4        9014491  61905422 \n6  1955 5        3007625  12316126.\n\nggplot(population_ranges) +\n  geom_ribbon(\n    aes(x = year, ymin = min_pop, ymax = max_pop, fill = cluster),\n    alpha = 0.8\n  ) +\n  scale_y_continuous(expand = c(0, 0, .1, .1), label = scales::label_number_si()) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_fill_manual(values = c(\"#80BFA2\", \"#7EB6D9\", \"#3E428C\", \"#D98BB6\", \"#BF2E21\", \"#F23A29\"))\n\n\n\n\n\n\n\n",
    "preview": "posts/2022-01-23-week01-02/week01-02_files/figure-html5/unnamed-chunk-4-1.png",
    "last_modified": "2022-02-20T09:54:38-06:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-01-23-week01-01/",
    "title": "Introduction to ggplot2",
    "description": "A discussion of ggplot2 terminology, and an example of iteratively refining a\nsimple scatterplot.",
    "author": [
      {
        "name": "Kris Sankaran",
        "url": {}
      }
    ],
    "date": "2021-01-26",
    "categories": [],
    "contents": "\n\n\n\nReading, Recording, Rmarkdown\nggplot2 is an R implementation of the Grammar of Graphics. The idea is to define the basic “words” from which visualizations are built, and then let users compose them in original ways. This is in contrast to systems with prespecified chart types, where the user is forced to pick from a limited dropdown menu of plots. Just like in ordinary language, the creative combination of simple building blocks can support a very wide range of expression.\nThese are libraries we’ll use in this lecture.\n\n\nlibrary(dplyr)\nlibrary(dslabs)\nlibrary(ggplot2)\nlibrary(ggrepel)\nlibrary(scales)\n\n\n\nComponents of a Graph\nWe’re going to create this plot in these notes.\n\n\n\nEvery ggplot2 plot is made from three components,\nData: This is the data.frame that we want to visualize.\nGeometry: These are the types of visual marks that appear on the plot.\nAesthetic Mapping: This links the data with the visual marks.\nThe Data\nLet’s load up the data. Each row is an observation, and each column is an attribute that describes the observation. This is important because each mark that you see on a ggplot – a line, a point, a tile, … – had to start out as a row within an R data.frame. The visual properties of the mark (e.g., color) are determined by the values along columns. These type of data are often referred to as tidy data, and we’ll have a full week discussing this topic.\nHere’s an example of the data above in tidy format,\n\n\ndata(murders)\nhead(murders)\n\n\n       state abb region population total\n1    Alabama  AL  South    4779736   135\n2     Alaska  AK   West     710231    19\n3    Arizona  AZ   West    6392017   232\n4   Arkansas  AR  South    2915918    93\n5 California  CA   West   37253956  1257\n6   Colorado  CO   West    5029196    65\n\nThis is one example of how the same information might be stored in a non-tidy way, making visualization much harder.\n\n\nnon_tidy <- data.frame(t(murders))\ncolnames(non_tidy) <- non_tidy[1, ]\nnon_tidy <- non_tidy[-1, ]\nnon_tidy[, 1:6]\n\n\n            Alabama   Alaska  Arizona Arkansas California Colorado\nabb              AL       AK       AZ       AR         CA       CO\nregion        South     West     West    South       West     West\npopulation  4779736   710231  6392017  2915918   37253956  5029196\ntotal           135       19      232       93       1257       65\n\nOften, one of the hardest parts in making a ggplot2 plot is not coming up with the right ggplot2 commands, but reshaping the data so that it’s in a tidy format.\nGeometry\nThe words in the grammar of graphics are the geometry layers. We can associate each row of a data frame with points, lines, tiles, etc., just by referring to the appropriate geom in ggplot2. A typical plot will compose a chain of layers on top of a dataset,\n\nggplot(data) + [layer 1] + [layer 2] + …\n\nFor example, by deconstructing the plot above, we would expect to have point and text layers. For now, let’s just tell the plot to put all the geom’s at the origin.\n\n\nggplot(murders) +\n  geom_point(x = 0, y = 0) +\n  geom_text(x = 0, y = 0, label = \"test\")\n\n\n\n\nYou can see all the types of geoms in the cheat sheet. We’ll be experimenting with a few of these in a later lecture.\nAesthetic mappings\nAesthetic mappings make the connection between the data and the geometry. It’s the piece that translates abstract data fields into visual properties. Analyzing the original graph, we recognize these specific mappings,\nState Population → \\(x\\)-axis coordinate\nNumber of murders → \\(y\\)-axis coordinate\nGeographical region → color\nTo establish these mappings, we need to use the aes function. Notice that column names don’t have to be quoted – ggplot2 knows to refer back to the murders data frame in ggplot(murders).\n\n\nggplot(murders) +\n  geom_point(aes(x = population, y = total, col = region))\n\n\n\n\nThe original plot used a log-scale. To transform the x and y axes, we can use scales.\n\n\nggplot(murders) +\n  geom_point(aes(x = population, y = total, col = region)) +\n  scale_x_log10() +\n  scale_y_log10()\n\n\n\n\nOnce nuance is that scales aren’t limited to \\(x\\) and \\(y\\) transformations. They can be applied to modify any relationship between a data field and its appearance on the page. For example, this changes the mapping between the region field and circle color.\n\n\nggplot(murders) +\n  geom_point(aes(x = population, y = total, col = region)) +\n  scale_x_log10() +\n  scale_y_log10() +\n  scale_color_manual(values = c(\"#6a4078\", \"#aa1518\", \"#9ecaf8\", \"#50838c\")) # exercise: find better colors using https://imagecolorpicker.com/\n\n\n\n\nA problem with this graph is that it doesn’t tell us which state each point corresponds to. For that, we’ll need text labels. We can encode the coordinates for these marks again using aes, but this time within a geom_text layer.\n\n\nggplot(murders) +\n  geom_point(aes(x = population, y = total, col = region)) +\n  geom_text(\n    aes(x = population, y = total, label = abb),\n    nudge_x = 0.08 # what would happen if I remove this?\n  ) +\n  scale_x_log10() +\n  scale_y_log10()\n\n\n\n\nNote that each type of layer uses different visual properties to encode the data – the argument label is only available for the geom_text layer. You can see which aesthetic mappings are required for each type of geom by checking that geom’s documentation page, under the Aesthetics heading.\nIt’s usually a good thing to make your code as concise as possible. For ggplot2, we can achieve this by sharing elements across aes calls (e.g., not having to type population and total twice). This can be done by defining a “global” aesthetic, putting it inside the initial ggplot call.\n\n\nggplot(murders, aes(x = population, y = total)) +\n  geom_point(aes(col = region)) +\n  geom_text(aes(label = abb), nudge_x = 0.08) +\n  scale_x_log10() +\n  scale_y_log10()\n\n\n\n\nFinishing touches\nHow can we improve the readability of this plot? You might already have ideas,\nPrevent labels from overlapping. It’s impossible to read some of the state names.\nAdd a line showing the national rate. This serves as a point of reference, allowing us to see whether an individual state is above or below the national murder rate.\nGive meaningful axis / legend labels and a title.\nMove the legend to the top of the figure. Right now, we’re wasting a lot of visual real estate in the right hand side, just to let people know what each color means.\nUse a better color theme.\nFor 1., the ggrepel package find better state name positions, drawing links when necessary.\n\n\nggplot(murders, aes(x = population, y = total)) +\n  geom_text_repel(aes(label = abb), segment.size = 0.2) + # I moved it up so that the geom_point's appear on top of the lines\n  geom_point(aes(col = region)) +\n  scale_x_log10() +\n  scale_y_log10()\n\n\n\n\nFor 2., let’s first compute the national murder rate,\n\n\nr <- murders %>% \n  summarize(rate = sum(total) /  sum(population)) %>%\n  pull(rate)\nr\n\n\n[1] 3.034555e-05\n\nNow, we can use this as the slope in a geom_abline layer, which encodes a slope and intercept as a line on a graph.\n\n\nggplot(murders, aes(x = population, y = total)) +\n  geom_abline(intercept = log10(r), size = 0.4, col = \"#b3b3b3\") +\n  geom_text_repel(aes(label = abb), segment.size = 0.2) +\n  geom_point(aes(col = region)) +\n  scale_x_log10() +\n  scale_y_log10()\n\n\n\n\nFor 3., we can add a labs layer to write labels and a theme to reposition the legend. I used unit_format from the scales package to change the scientific notation in the \\(x\\)-axis labels to something more readable.\n\n\nggplot(murders, aes(x = population, y = total)) +\n  geom_abline(intercept = log10(r), size = 0.4, col = \"#b3b3b3\") +\n  geom_text_repel(aes(label = abb), segment.size = 0.2) +\n  geom_point(aes(col = region)) +\n  scale_x_log10(labels = unit_format(unit = \"million\", scale = 1e-6)) + # used to convert scientific notation to readable labels\n  scale_y_log10() +\n  labs(\n    x = \"Population (log scale)\",\n    y = \"Total number of murders (log scale)\",\n    color = \"region\",\n    title = \"US Gun Murders in 2010\"\n  ) +\n  theme(legend.position = \"top\")\n\n\n\n\nFor 5., I find the gray background with reference lines a bit distracting. We can simplify the appearance using theme_bw. I also like the colorbrewer palette, which can be used by calling a different color scale.\n\n\nggplot(murders, aes(x = population, y = total)) +\n  geom_abline(intercept = log10(r), size = 0.4, col = \"#b3b3b3\") +\n  geom_text_repel(aes(label = abb), segment.size = 0.2) +\n  geom_point(aes(col = region)) +\n  scale_x_log10(labels = unit_format(unit = \"million\", scale = 1e-6)) +\n  scale_y_log10() +\n  scale_color_brewer(palette = \"Set2\") +\n  labs(\n    x = \"Population (log scale)\",\n    y = \"Total number of murders (log scale)\",\n    color = \"Region\",\n    title = \"US Gun Murders in 2010\"\n  ) +\n  theme_bw() +\n  theme(\n    legend.position = \"top\",\n    panel.grid.minor = element_blank()\n  )\n\n\n\n\nSome bonus exercises, which will train you to look at your graphics more carefully, as well as build your familiarity with ggplot2.\nTry reducing the size of the text labels. Hint: use the size argument in geom_text_repel.\nIncrease the size of the circles in the legend. Hint: Use override.aes within a guide.\nRe-order the order of regions in the legend. Hint: Reset the factor levels in the region field of the murders data.frame.\nOnly show labels for a subset of states that are far from the national rate. Hint: Filter the murders data.frame, and use a data field specific to the geom_text_repel layer.\n\n\n\n",
    "preview": "posts/2022-01-23-week01-01/week01-01_files/figure-html5/unnamed-chunk-3-1.png",
    "last_modified": "2022-02-20T09:54:36-06:00",
    "input_file": {}
  }
]
